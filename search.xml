<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Network-TCP-IP</title>
      <link href="/2021/09/21/network-tcp-ip/"/>
      <url>/2021/09/21/network-tcp-ip/</url>
      
        <content type="html"><![CDATA[<h2 id="【计算机网络基础系列】02-TCP-IP-概述"><a href="#【计算机网络基础系列】02-TCP-IP-概述" class="headerlink" title="【计算机网络基础系列】02- TCP/IP 概述"></a>【计算机网络基础系列】02- TCP/IP 概述</h2><blockquote><p>最近复习计算机网络相关知识，重温《图解TCP/IP》</p></blockquote><h3 id="关于-TCP-IP-的具体含义"><a href="#关于-TCP-IP-的具体含义" class="headerlink" title="关于 TCP/IP 的具体含义"></a>关于 TCP/IP 的具体含义</h3><ul><li>从字面意义上讲，有人可能会认为 TCP/IP 是指 TCP 与 IP 两种协议。实际生活中有时也确实就是指这两种协议。</li><li>然而在很多情况下，它只是利用 IP 进行通信时所必须用到的协议群的统称。</li><li>具体来说，IP 或 ICMP、TCP 或 UDP、TELNET 或 FTP、以及HTTP等都属于 TCP/IP 的协议。</li><li>它们与 TCP 或 IP 的关系紧密，是互联网必不可少的组成部分。</li><li>TCP/IP 一词泛指这些协议，因此，有时也称 TCP/IP 为网际协议族。</li></ul><blockquote><p>网际协议族（Internet Protocol Suite）: 组成网际协议的一组协议。</p></blockquote><h3 id="TCP-IP-发展历史与重要事件"><a href="#TCP-IP-发展历史与重要事件" class="headerlink" title="TCP/IP 发展历史与重要事件"></a>TCP/IP 发展历史与重要事件</h3><ul><li><p>20世纪60年代，以美国国防部（DoD，The Department of Defense）为中心的组织着力研究新的通信技术。</p></li><li><p>DoD 认为研发新的通信技术对于国防军事有着举足轻重的作用。</p></li><li><p>DoD 希望在通信传输的过程中，即使遭到了敌方的攻击和破坏，也可以经过迂回线路实现最终通信，保证通信不中断。</p></li><li><p>由此，出现了分布式网络、分组交换技术。</p></li><li><p>1969年，ARPANET 诞生。开发分组交换技术。<br>起初，只连接了UCLA（加州大学洛杉矶分校）、UCSB（加州大学圣芭芭拉分校）、SRI（斯坦福研究所）和犹他州大学这4个节点。</p></li><li><p>ARPANET 是全球互联网的鼻祖。</p></li><li><p>1975年，TCP/IP诞生。</p></li><li><p>1982年，TCP/IP规范出炉。UNIX 是最早开始实现TCP/IP的协议。</p></li><li><p>1983年，ARPANET 决定正式启用 TCP/IP 为通信协议。 TCP/IP 成为 ARPANET 网络唯一指定的协议。</p></li><li><p>1989年左右，局域网上的TCP/IP应用迅速扩大。</p></li><li><p>1990年左右，不论是局域网还是广域网，都开始倾向于使用 TCP/IP。</p></li><li><p>1995年左右，互联网开始商用，互联网服务供应商的数量剧增。</p></li><li><p>1996年，IPV6规范出炉，载入RFC。后于 1998 年修订。</p></li></ul><blockquote><p>关于分组交换(详见《图解 TCP/IP》一书 P30)：<br>目前网络通信方式大致分为两种——电路交换与分组交换。<br>电路交换技术的历史相对久远，主要用于过去的电话网。 在电路交换中，交换机主要负责数据的中转处理。如果一条电路连接了多台计算机，会出现一些问题。<br>因此，人们想到新方法，即 让连接到通信电路的计算机将所要发送的数据分成多个数据包，按照一定的顺序排列之后分别发送。这就是分组交换。<br>有了分组交换，数据被细分后，所有的计算机就可以一齐收发数据，这样也就提高了通信线路的利用率。<br>在分组交换中，由分组交换机（路由器）连接通信线路。<br>分组交换也有另一个名称：蓄积交换。</p></blockquote><h3 id="TCP-IP-标准化精髓"><a href="#TCP-IP-标准化精髓" class="headerlink" title="TCP/IP 标准化精髓"></a>TCP/IP 标准化精髓</h3><ul><li>TCP/IP协议的标准化过程有两大特点：一是具有开放性，二是注重实用性，即被标准化的协议能否被实际运用。</li><li>首先，开放性是由于 TCP/IP 的协议是由 IETF 讨论制定的，而 IETF 本身就是一个允许任何人加入进行讨论的组织。</li><li>其次，在TCP/IP 的标准化过程中，制定某一协议的规范本身已经不再那么重要，而首要任务是实现真正能够通信的技术。<br>难怪有人打趣到”TCP/IP 简直就是先开发程序，后写规格标准”。</li><li>经过一次又一次的讨论、实验和研究，一款协议的规范才会最终诞生。</li></ul><blockquote><ul><li>相比 TCP/IP，OSI 之所以未能达到普及，主要原因在于未能尽早地制定可行性较强的协议、未能提出应对技术快速革新的协议以及没有能及时进行后期改良的方案这几点。</li></ul></blockquote><ul><li>TCP/IP 规范中需要标准化的协议，被人们列入 RFC（Request For Comment） 文档并在互联网上公布。 </li><li>例如 IP 协议的规范由 RFC279 制定，TCP 协议的规范由 RFC793 号文档决定。</li></ul><blockquote><p>说明：关于 IETF 与 OSI 的介绍请参考上一篇文章。</p></blockquote><h3 id="TCP-IP-协议分层模型"><a href="#TCP-IP-协议分层模型" class="headerlink" title="TCP/IP 协议分层模型"></a>TCP/IP 协议分层模型</h3><blockquote><p>参考资料：维基百科- TCP/IP<br><a href="https://en.jinzhao.wiki/wiki/Internet_protocol_suite">https://en.jinzhao.wiki/wiki/Internet_protocol_suite</a><br>关于 OSI 参考模型中的 7层 分层，请参考上一篇文章。</p></blockquote><ul><li><p>从维基百科资料可知，对于TCP/IP协议分层一般有2种不同流派：一种是分为4层、一种是分为5层，区别在于是否有 硬件层（物理层）。</p></li><li><p>此外，不同的论文、书籍中，对于每层的叫法也有所区别。</p></li><li><p>这里我们把5层都做一下简单介绍，并且和OSI模型做一下简单对比。</p></li><li><p>TCP/IP 协议分层模型中，从下往上依次是：硬件层（物理层）、网络接口层（数据链路层）、互联网层（网络层）、传输层、应用层（会话层以上的分层）。</p></li></ul><h5 id="硬件层（物理层）"><a href="#硬件层（物理层）" class="headerlink" title="硬件层（物理层）"></a>硬件层（物理层）</h5><ul><li>TCP/IP 的最底层是负责数据传输的硬件。这种硬件就相当于以太网或电话线路等物理层的设备。</li><li>关于它的内容一直无法统一定义。</li><li>因为只要人们在物理层上所使用的的传输媒介（例如使用网线或无线），网络的带宽、可靠性、安全性、延迟等都会有所不同，而在这些方面有没有一个既定的指标。</li><li>总之，TCP/IP 是在网络互连的设备之间能够通信的前提下才被提出的协议。</li></ul><h5 id="网络接口层（数据链路层）"><a href="#网络接口层（数据链路层）" class="headerlink" title="网络接口层（数据链路层）"></a>网络接口层（数据链路层）</h5><blockquote><p>有时人们也将网络接口层和硬件层合并起来称作 网络通信层。 </p></blockquote><ul><li>网络接口层利用以太网中的数据链路层进行通信，因此属于接口层。 也就是说，把它当做让 NIC 起作用的驱动程序也无妨。</li><li>驱动程序是在操作系统与硬件之间起到桥梁作用的软件。</li></ul><h5 id="互联网层（网络层）"><a href="#互联网层（网络层）" class="headerlink" title="互联网层（网络层）"></a>互联网层（网络层）</h5><ul><li>互联网层使用 IP 协议，它相当于 OSI 模型中的第3层网络层。</li></ul><blockquote><ul><li><p>IP 协议基于IP地址转发分包数据。</p></li><li><p>TCP/IP 分层中的互联网曾与传输层的功能通常由操作系统提供。尤其是路由器，它必须得实现通过互联网层转发分组数据包的功能。</p></li><li><p>此外，连接互联网的所有主机跟路由器都必须实现IP的功能。</p></li><li><p>其他连接互联网的网络设备（如网桥、中继器或集线器）就没必要一定实现IP或TCP的功能。</p></li><li><p>IP 是跨越网络传送数据包，使整个互联网都能收到数据的协议。</p></li><li><p>IP 协议使数据能够发送到地球的另一端，这期间它使用IP地址作为主机的标识。</p></li><li><p>IP 还隐含着数据链路层的功能。通过IP，相互通信的主机之间不论经过怎样的底层数据链路都能实现通信。</p></li><li><p>虽然IP也是分组交换的一种协议，但是它不具有重发机制。因此，属于非可靠性传输协议。</p></li></ul></blockquote><ul><li>ICMP</li></ul><blockquote><ul><li>IP 数据包在发送途中一旦发生异常导致无法到达对端目标地址时，需要给发送端发送一个发生异常的通知。 </li><li>ICMP 就是为这一功能而制定的。它有时也被用来诊断网络的健康状况。</li></ul></blockquote><ul><li>ARP：从分组数据包的IP地址中解析出物理地址（MAC 地址）的一种协议。</li></ul><h5 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h5><ul><li><p>TCP/IP 的传输层有两个具有代表性的协议（TCP 与 UDP）。该层的功能本身与OSI参考模型中的传输层类似。</p></li><li><p>传输层最主要的功能就是能够让应用程序之间实现通信。</p></li><li><p>计算机内部，通常同一时间运行着多个程序。为此，必须分清是哪些程序与哪些程序在进行通信。</p></li><li><p>识别这些应用程序的是端口号。</p></li><li><p>TCP是一种面向有连接的传输层协议。</p></li></ul><blockquote><ul><li>TCP可以保证两端通信主机之间的通信可达。</li><li>TCP能够正确处理在传输过程中丢包、传输顺序乱掉等异常情况。</li><li>此外，TCP还能够有效利用带宽，缓解网络拥堵。</li><li>然而，为了建立和断开连接，有时它需要至少7次的发包收包，导致网络流量的浪费。</li><li>此外，为了提高网络的利用率，TCP协议中定义了各种各样复杂的规范，因此不利于视频会议（音频、视频的数据量既定）等场合使用。</li></ul></blockquote><ul><li>UDP有别于TCP，它是一种面向无连接的传输层协议。</li></ul><blockquote><ul><li>UDP 不会关注对端是否真的收到了传送过去的数据，如果需要检查对端是否受到分组数据包，或者对端是否连接到网络，则需要在应用程序中实现。</li><li>UDP 通常用于分组数据较少或多播、广播通信以及视频通信等多媒体领域。</li></ul></blockquote><h5 id="应用层（会话层以上的分层）"><a href="#应用层（会话层以上的分层）" class="headerlink" title="应用层（会话层以上的分层）"></a>应用层（会话层以上的分层）</h5><ul><li><p>TCP/IP 应用的架构绝大多数属于客户端/服务端模型。提供服务的程序叫服务端，接受服务的程序叫客户端。</p></li><li><p>WWW</p></li></ul><blockquote><ul><li>WWW 万维网可以说是互联网能够如此普及的一个重要原动力。</li><li>浏览器与服务端之间通信所用的协议是HTTP（HyperText Transter Protocol）。</li><li>所传输数据的主要格式是HTML（Hypertext Markup Language）。</li><li>WWW中的HTTP属于OSI应用层的协议，而HTML属于表示层的协议。</li></ul></blockquote><ul><li>电子邮件（E-Mail）</li></ul><blockquote><ul><li>发送电子邮件时用到的协议叫做 SMTP（Simple Mail Transfer Protocol）。</li><li>最初，人们只能发送文本格式的电子邮件。然后现在，电子邮件的格式由 MIME 协议扩展以后，就可以发送声音、图像等各式各样的信息。</li><li>这里提到的 MIME 属于OSI参考模型的第6层——表示层。</li></ul></blockquote><ul><li>文件传输（FTP）</li></ul><blockquote><ul><li>文件传输是指将保存在其他计算机硬盘上的文件转移到本地的硬盘上，或将本地硬盘的文件传送到其他机器硬盘上的意思。</li><li>该过程使用的协议叫做 FTP（File Transfer Protocol）。</li><li>FTP很早就已经投入使用，传输过程中可以选择用二进制方式还是文本方式。</li><li>在FTP进行文件传输时会建立两个TCP连接，分别是发出传输请求时所要用到的控制连接与实际传输数据时所要用到的数据连接。</li><li>这两种连接的控制管理属于会话层的功能。</li></ul></blockquote><ul><li><p>远程登录（TELNET 与 SSH）：TCP/IP 网络中远程登录常用TELNET和SSH两种协议。</p></li><li><p>网络管理（SNMP）</p></li></ul><blockquote><ul><li>在TCP/IP中进行网络管理时，采用SNMP（Simple Network Management Protocol）协议。</li><li>使用SNMP管理的主机、网桥、路由器等称作SNMP代理（Agent），而进行管理的那一段叫做管理器（Manager）。</li><li>SNMP正式这个Manager域Agent所要用到的协议。</li><li>在SNMP的代理端，保存着网络接口的信息、通信数据量、异常数据量以及设备温度等信息。<br>这些信息可以通过MIB（Management Information Base）访问。</li><li>因此，在TCP/IP的网络管理中，SNMP属于应用协议，MIB属于表示层协议。  </li></ul></blockquote><h3 id="关于-TCP-IP-协议分层的思想"><a href="#关于-TCP-IP-协议分层的思想" class="headerlink" title="关于 TCP/IP 协议分层的思想"></a>关于 TCP/IP 协议分层的思想</h3><blockquote><p>详见 《图解TCP/IP》 P123</p></blockquote><ul><li><p>IP 属于面向无连接型。</p></li><li><p>为了提高可靠性，上一层的TCP采用面向有连接型。</p></li><li><p>IP提供尽力服务（Best Effort），意指”为了把数据包发送到最终目标地址，尽最大努力”。然而，它并不做”最终收到与否的验证”。</p></li><li><p>IP数据包在途中可能会发生丢包、错位以及数据量翻倍等问题。</p></li><li><p>因此提高通信的可靠性很重要。TCP就提供这种功能。</p></li><li><p>如果说IP只负责将数据发送给目标主机，那么 TCP 则负责保证对端主机确实接收到数据。</p></li><li><p>为什么不让IP具有可靠传输的功能，从而把这两种协议合并到一起呢？</p></li></ul><blockquote><ul><li>这是因为，如果要一种协议规定所有的功能和作用，那么该协议的具体实施和编程就会变得非常复杂，无法轻易实现。</li><li>相比之下，按照网络分层，明确定义每层协议的作用和责任以后，针对每层具体的协议进行编程会更加有利于该协议的实现。</li><li>网络通信中如果能进行有效分层，就可以明确TCP与IP各自协议的最终目的，也有利于后续对这些协议进行扩展和性能上的优化。</li><li>分层也简化了每个协议的具体实现。</li><li>互联网能够发展到今天，与网络通信的分层密不可分。</li></ul></blockquote><ul><li>类似于计算机编程中的模块化。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 TCP IP 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Network-OSI</title>
      <link href="/2021/09/21/network-osi/"/>
      <url>/2021/09/21/network-osi/</url>
      
        <content type="html"><![CDATA[<h2 id="【计算机网络基础系列】01-OSI-参考模型"><a href="#【计算机网络基础系列】01-OSI-参考模型" class="headerlink" title="【计算机网络基础系列】01- OSI 参考模型"></a>【计算机网络基础系列】01- OSI 参考模型</h2><blockquote><p>最近复习计算机网络相关知识，重温《图解TCP/IP》</p></blockquote><h3 id="协议的标准化"><a href="#协议的标准化" class="headerlink" title="协议的标准化"></a>协议的标准化</h3><blockquote><ul><li>ISO: International Organization for Standards, 国际标准化组织。</li><li>OSI: Open Systems Interconnection, 开放式通信系统互联参考模型。</li></ul></blockquote><ul><li><p>为了让不同厂商生产的异构机型也能互相通信，ISO 制定了一个国际标准 OSI，对通信系统进行了标准化。</p></li><li><p>现在，OSI 所定义的协议虽然并没有得到普及, 但是在OSI协议设计之初作为其指导方针的OSI 参考模型却常被用于网络协议的制定当中。</p></li><li><p>我们经常提到的（也是该书中重点介绍的） TCP/IP 并非 ISO 所制定的某种国际标准。而是由 IETF 所建议的、致力于推进其标准化作业的一种协议。</p></li><li><p>TCP/IP 作为互联网之上的一种标准，也作为业界标准，俨然已经成为全世界所广泛应用的通信协议。</p></li></ul><blockquote><ul><li>IETF: Internet Engineering Task Force, 国际互联网工程任务组</li><li>TCP/IP: 请注意，在很多情况下，TCP/IP 并不是单纯指 TCP 与 IP 这两种协议，而是指利用IP进行通信时所用到的协议群的统称。详见下文。</li><li>业界标准：非国家或国际机构等公共机构所制定的标准，但属于业界公认的标准。<br>（类似：截至2021年，我们认为 Kubernetes 是容器编排领域的业界标准。）</li></ul></blockquote><ul><li>协议得以标准化也使所有遵循标准协议的设备不再因计算机硬件或操作系统的差异而无法通信。</li><li>因此，协议的标准化也推动了计算机网络的普及。</li></ul><h3 id="关于-OSI-参考模型"><a href="#关于-OSI-参考模型" class="headerlink" title="关于 OSI 参考模型"></a>关于 OSI 参考模型</h3><ul><li>OSI: Open Systems Interconnection, 开放式通信系统互联参考模型。</li><li>OSI 将通信功能划分为 7 个分层，称作 OSI 参考模型。</li><li>这7层从底层往上依次是：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。  </li><li>许多通信协议都对应了 OSI 参考模型中7个分层中的某层。通过这一点，可以大致了解该协议在整个通信功能中的位置和作用。</li></ul><h3 id="OSI-参考模型中各个分层的作用"><a href="#OSI-参考模型中各个分层的作用" class="headerlink" title="OSI 参考模型中各个分层的作用"></a>OSI 参考模型中各个分层的作用</h3><table><thead><tr><th>序号</th><th>分层名称</th><th>功能</th><th>每层功能概览</th></tr></thead><tbody><tr><td>7</td><td>应用层</td><td>针对特定应用的协议。</td><td>电子邮件–电子邮件协议，远程登录——远程登录协议，文件传输——文件传输协议</td></tr><tr><td>6</td><td>表示层</td><td>设备固有数据格式和网络标准数据格式的转换。</td><td>接收不同表现形式的信息，如文字流、图像、声音等，并实现转换</td></tr><tr><td>5</td><td>会话层</td><td>通信管理。负责建立和断开连接（数据流动的逻辑通路）。管理传输层以下的分层。</td><td>何时建立连接，何时断开连接以及保持多久的连接？</td></tr><tr><td>4</td><td>传输层</td><td>管理两个节点之间的数据传输。负责可靠传输（确保数据被可靠地传送到目标地址）。</td><td>是否有数据丢失？</td></tr><tr><td>3</td><td>网络层</td><td>地址管理与路由选择。</td><td>经过哪个路由传递到目标地址？</td></tr><tr><td>2</td><td>数据链路层</td><td>互连设备之间传送和识别数据帧。</td><td>数据帧与比特流之间的转换，分段转发</td></tr><tr><td>1</td><td>物理层</td><td>以 0、1 代表电压的高低、灯光的闪灭。界定连接器和网线的规格。</td><td>比特流与电子信号之间的切换，连接器与网线的规格。</td></tr></tbody></table><ul><li><p>应用层：为应用程序提供服务并规定应用程序中通信相关的细节。包括文件传输、电子邮件、远程登录等协议。</p></li><li><p>表示层：将应用处理的信息转换为适合网络传输的格式，或将来自下一层的数据转换为上层能够处理的格式。因此它主要负责数据格式的转换。<br>具体来说，就是将设备固有的数据格式转换为网络标准传输格式。不同设备对同一比特流解释的结果可能会不同。<br>因此，使它们保持一致是这一层的主要作用。</p></li><li><p>会话层：负责建立和断开通信连接（数据流动的逻辑通路），以及数据的分割等数据传输相关的管理。</p></li><li><p>传输层：起着可靠传输的作用。只在通信双方节点上进行处理，而无需在路由器上处理。</p></li><li><p>网络层：将数据传输到目标地址。目标地址可以是多个网络通过路由器连接而成的某一个地址。因此这一层主要负责寻址和路由选择。</p></li><li><p>数据链路层：负责物理层面上互连的、节点之间的通信传输。例如与1个以太网相连的2个节点之间的通信。</p></li><li><p>物理层：负责0、1比特流（0、1序列）与电压的高低、光的闪灭之间的互换。</p></li></ul><h3 id="关于-OSI-协议分层的思想"><a href="#关于-OSI-协议分层的思想" class="headerlink" title="关于 OSI 协议分层的思想"></a>关于 OSI 协议分层的思想</h3><ul><li><p>分层的优点：</p><ul><li>协议分层就如同计算机软件中的模块化开发。</li><li>分层使得每个分层独立使用，即使系统中某些分层发生了变化，也不会波及整个系统。</li><li>可以构造一个扩展性和灵活性都较强的系统。</li><li>此外，通过分层能够细分通信功能，更易于单独实现每个分层的协议，并界定各个分层的具体责任和义务。</li></ul></li><li><p>分层的劣势：可能就在于过分模块化，使处理变得更加沉重以及每个模块都不得不实现相似的处理逻辑等问题。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 OSI 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CleanCode01</title>
      <link href="/2021/08/29/cleancode/cleancode01/"/>
      <url>/2021/08/29/cleancode/cleancode01/</url>
      
        <content type="html"><![CDATA[<h2 id="《代码整洁之道》学习笔记01-整洁代码"><a href="#《代码整洁之道》学习笔记01-整洁代码" class="headerlink" title="《代码整洁之道》学习笔记01-整洁代码"></a>《代码整洁之道》学习笔记01-整洁代码</h2><blockquote><p>《代码整洁之道》 作者：罗伯特.C.马丁（Bob大叔）<br>《Clean Code》 Robert C.Martin</p></blockquote><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>阅读该书有2种原因：第一，你是个程序员；第二，你想成为更好的程序员。</p><h3 id="1-1-要有代码"><a href="#1-1-要有代码" class="headerlink" title="1.1 要有代码"></a>1.1 要有代码</h3><ul><li>代码永存！</li><li>我们永远抛不掉代码，因为代码呈现了需求的细节。在某些层面上，这些细节无法被忽略或抽象，必须明确之。</li><li>将需求明确到机器可以执行的细节程度，就是编程要做的事。而这种规约正是代码。</li><li>实际上，在较高层次上用领域特定语言撰写的规约也将是代码！它也得严谨、精确、规范和详细，好让机器理解和执行。</li><li>记住，代码确然是我们最终用来表达需求的那种语言。我们可以创造各种与需求接近的语言。。我们可以创造帮助把需求解析和汇总为正式结构的各种工具。</li><li>然而，我们永远无法抛弃必要的精确性——所以代码永存。</li></ul><h3 id="1-2-糟糕的代码"><a href="#1-2-糟糕的代码" class="headerlink" title="1.2 糟糕的代码"></a>1.2 糟糕的代码</h3><ul><li>我认为好代码是该领域最强固、最受支持、最被强调的前提了。</li><li>我们知道好代码重要，是因为其短缺实在困扰了我们太久。</li><li>勒布朗（LeBlanc）法则：稍后等于永不（Later equals never）。</li></ul><h3 id="1-3-混乱的代价"><a href="#1-3-混乱的代价" class="headerlink" title="1.3 混乱的代价"></a>1.3 混乱的代价</h3><ul><li>随着混乱的增加，团队生产力也持续下降，以致趋近于零。（备注：后续可以结合技术债来进行一些总结）</li><li>花时间保持代码整洁不但关乎效率，还关乎生存。</li></ul><blockquote><p>为什么好代码会这么快就变质成糟糕的代码？理由多得很。<br>我们抱怨需求变化背离了初期设计。我们哀叹进度太紧张，没法干好活。<br>我们把问题归咎于愚蠢的经理、苛求的用户、没用的营销手段和那些电话消毒剂。<br>不过，亲爱的呆伯特（Dilbert），我们是自作自受。我们太不专业了。</p></blockquote><ul><li><p>“不听经理的，我就会被炒鱿鱼。” 多半不会。多数经理想要知道实情，即便他们看起来不喜欢实情。</p></li><li><p>经理他们会分离卫护进度和需求；那是他们该干的。你则当以同等的热情卫护代码。</p></li><li><p><strong>守护代码、写好代码是程序员的本职工作，而不是经理的本职工作；所以，程序员应该守护自己的代码，这是专业性的体现。</strong></p></li><li><p>不要指望其他人来帮助你保持专业性，而是应该由你自己来坚守专业性。</p></li><li><p>医生如果按照病人说的办（在给他做手术前别洗手以节约时间），就是一种不专业的态度（更别说是犯罪了）。</p></li><li><p>同理，程序员遵从不了解混乱风险的经理的意愿，也是不专业的做法。</p></li><li><p>制造混乱无助于赶上期限。</p></li><li><p>赶上期限的唯一方法——做得快的唯一方法——就是始终尽可能保持代码整洁。</p></li></ul><h3 id="1-3-4-整洁代码的艺术"><a href="#1-3-4-整洁代码的艺术" class="headerlink" title="1.3.4 整洁代码的艺术"></a>1.3.4 整洁代码的艺术</h3><ul><li>这一节值得深思，单独整理出来。</li><li>坏消息是，写整洁代码很像是绘画。多数人都知道一幅画是好是坏，但能分辨优劣并不表示懂得绘画。</li><li>写整洁代码，需要遵循大量的小技巧，贯彻刻苦习得的”整洁感”。</li><li><strong>这种”代码感”就是关键所在。</strong></li><li>编写整洁代码的程序员就像是艺术家，他能用一系列变换把一块白板变作由优雅代码构成的系统。</li></ul><h3 id="1-3-5"><a href="#1-3-5" class="headerlink" title="1.3.5"></a>1.3.5</h3><ul><li>这一节很关键，值得反复研读，单独整理出来。</li></ul><h5 id="C-发明者的观点"><a href="#C-发明者的观点" class="headerlink" title="C++发明者的观点"></a>C++发明者的观点</h5><ul><li>Bjarne Stroustup，C++语言发明者，《C++ Programming Language》一书作者：</li></ul><blockquote><p>我喜欢优雅和高效的代码。<br>代码逻辑应当直截了当，令缺陷难以隐藏；<br>尽量减少依赖关系，使之便于维护；<br>依据某种分层战略完善错误处理代码；<br>性能调至最优，省得引诱别人做没规矩的优化，搞出一堆混乱来。<br>整洁的代码只做好一件事。</p></blockquote><ul><li><p>Bjarne用了”优雅”一词。说得好！优雅的定义：外表或举止上令人愉悦的优美和雅观；令人愉悦的精致和简单。</p></li><li><p>注意对”愉悦”一词的强调。Bjarne显然认为整洁的代码读起来令人愉悦。</p></li><li><p>读这种代码，就像见到手工精美的音乐盒或设计精良的汽车一般，让你会心一笑。</p></li><li><p>务实的Dave Thomas 和 Andy Hunt 从另一个角度阐述了”糟糕的代码引发混乱！”，他们提到破窗理论。</p></li><li><p>Bjarne 也提到完善错误处理代码，往深处说就是在细节上花心思。凸显出整洁代码对细节的重视。</p></li><li><p>Bjarne 以””整洁的代码只做好一件事”结束论断。毋庸置疑，软件设计的许多原则最终都会归结为这句警语。</p></li></ul><h5 id="《面向对象分析与设计》作者观点"><a href="#《面向对象分析与设计》作者观点" class="headerlink" title="《面向对象分析与设计》作者观点"></a>《面向对象分析与设计》作者观点</h5><ul><li>Brady Booch，《Object Oriented Analysis and Design with Application》一书作者：</li></ul><blockquote><p>整洁的代码简单直接。<br>整洁的代码如同优美的散文。<br>整洁的代码从不隐藏设计者的意图，充满了干净利落的抽象和直截了当的控制语句。</p></blockquote><ul><li>Grady的观点与Bjarne的观点有类似之处，但他从可读性的角度来定义。</li><li>我特别喜欢”整洁的代码如同优美的散文”这种看法。</li><li>代码应当讲述事实，不引人猜测。它只该包含必需之物。</li></ul><h5 id="Eclipse-战略教父的观点"><a href="#Eclipse-战略教父的观点" class="headerlink" title="Eclipse 战略教父的观点"></a>Eclipse 战略教父的观点</h5><ul><li>“老大” Dave Thomas，OTI公司创始人，Eclipse 战略教父：</li></ul><blockquote><p>整洁的代码可由作者之外的开发者阅读和增补。<br>它应当有单元测试和验收测试。<br>它使用有意义的命名。<br>它只提供一种而非多种做一件事的途径。<br>它只有尽量少的依赖关系，而且要明确地定义和提供清晰的、尽量少的API。<br>代码应通过其字面表达含义，因为不同的语言导致并非所有必需的信息均可通过代码自身清晰表达。</p></blockquote><ul><li>Dave断言，整洁的代码变化与其他人予以增补。（开放闭合原则 OCP）</li><li>Dave将整洁系于测试之上！</li><li>应当用人类可读的方式来写代码。（源自Knuth的”字面编程”）</li></ul><h5 id="《修改代码的艺术》作者的观点"><a href="#《修改代码的艺术》作者的观点" class="headerlink" title="《修改代码的艺术》作者的观点"></a>《修改代码的艺术》作者的观点</h5><ul><li>Michael Feathers，《Working Effectively with Legacy Code》一书作者：</li></ul><blockquote><p>我可以列出我留意的整洁代码的所有特点，但其中有一条是根本性的。<br>整洁的代码总是看起来像是某位特别在意它的人写的。<br>几乎没有改进的余地。<br>代码的作者什么都想到了，如果你企图改进它，总会回到原点，赞叹某人留给你的代码——全心投入的某人留下的代码。</p></blockquote><ul><li>一言以蔽之：在意。</li><li>这就是本书的题旨所在。或许该加个副标题，如何在意代码。</li></ul><h5 id="《极限编程实施》作者的观点"><a href="#《极限编程实施》作者的观点" class="headerlink" title="《极限编程实施》作者的观点"></a>《极限编程实施》作者的观点</h5><ul><li>Ron Jeffries，《Extreme Proramming Installed》以及《Extreme Programming Adventure in C#》作者</li><li>Ron 初入行就在战略空军司令部编写Fortran程序，此后几乎在每种机器上编写过每种语言的代码。他的言论值得咀嚼。</li></ul><blockquote><p>节选：<br>近年来，我开始研究贝克的简单代码规则，差不多也都琢磨透了。简单代码，依其重要顺序：<br>能通过所有测试；<br>没有重复代码；<br>体现系统中的全部设计理念；<br>包括尽量少的实体，比如类、方法、函数等。<br>在以上诸项中，我最在意代码重复。<br>（中间略过，感兴趣请读原文）<br>减少重复代码，提高表达力，提早构建简单抽象。这就是我写整洁代码的方法。</p></blockquote><ul><li>Ron以寥寥数段文字概括了本书的全部内容。</li><li>不要重复代码，只做一件事——表达力，小规模抽象。该有的都有了。</li></ul><h5 id="Wiki发明者、极限编程创始人之一的观点"><a href="#Wiki发明者、极限编程创始人之一的观点" class="headerlink" title="Wiki发明者、极限编程创始人之一的观点"></a>Wiki发明者、极限编程创始人之一的观点</h5><ul><li>Ward Cunningham，Wiki发明者，Extreme Programming的创始人之一，Smalltalk 语言和面向对象的思想领袖。所有在意代码者的”教父”。</li></ul><blockquote><p>如果每个例程都让你赶到深合己意，那就是整洁代码。<br>如果代码让编程语言看起来像是转为解决那个问题而存在的，就可以称之为漂亮的代码。</p></blockquote><h3 id="1-4-思想流派"><a href="#1-4-思想流派" class="headerlink" title="1.4 思想流派"></a>1.4 思想流派</h3><ul><li>我（”鲍勃大叔”）又是怎么想的呢？在我眼中整洁代码是什么样的？</li><li>本书将以详细到吓死人的程度告诉你，我和我的同道对整洁代码的看法。</li><li>任何门派都并非绝对正确。</li><li>可以把本书看作是对象导师（Object Mentor，作者开的咨询培训公司）整洁代码派的说明。</li><li>书中要传授的就是我们勤操己艺的方法。</li><li>实际上，书中很多建议都存在争议。可以参考、但不必一味盲从。</li></ul><h3 id="1-5-我们是作者"><a href="#1-5-我们是作者" class="headerlink" title="1.5 我们是作者"></a>1.5 我们是作者</h3><ul><li>Javadoc中的 @author 字段告诉我们自己是什么人。我们是作者。作者都有读者。</li><li>实际上，作者有责任与读者做良好沟通。下次你写代码的时候，记得自己是作者，要为评判你工作的读者写代码。</li><li>你或许会问：代码真正”读”的成分有多少呢？难道主要力量不是应该用在”写”上吗？</li><li>作者玩过”编辑器回放”，回放过程显示，多数时间都是在滚动屏幕，浏览其他模块！</li><li>你该明白了。花费读与写的时间的比例超过 10 ： 1。写新代码时，我们一直在读旧代码。</li><li>既然比例如此之高，我们就想让读的过程变得轻松，即便那会使编写过程更难。不可能光写不读，所以使之易读也就是使之易写。</li><li>这事概无例外。不读周边代码就没法写代码。</li><li>编写代码的难度，取决于读周边代码的难度。</li><li>要想干得快，要想早点做完，要想轻松写代码，先让代码易读吧。</li></ul><h3 id="1-6-童子军军规"><a href="#1-6-童子军军规" class="headerlink" title="1.6 童子军军规"></a>1.6 童子军军规</h3><ul><li>光把代码写好可不够。必须时时保持代码整洁。</li><li>借用没改过童子军一条简单的军规，应用到我们的专业领域： <strong>让营地比你来时更干净。</strong></li><li>如果每次签入时，代码都比签出时干净，那么代码就不会腐坏。</li><li>清理并不一定要花多少功夫，也许知识改好一个变量名，拆分一个有点过长的函数，消除一点点重复代码，清理一个嵌套if语句。</li></ul><h3 id="1-7-前传与原则"><a href="#1-7-前传与原则" class="headerlink" title="1.7 前传与原则"></a>1.7 前传与原则</h3><ul><li>本书是2002年我的那本《敏捷软件开发：原则、模式与实践》的”前传”。</li><li>《Agile Software Development： Principles，Patterns and Practices》，简称PPP</li></ul><h3 id="1-8-小结"><a href="#1-8-小结" class="headerlink" title="1.8 小结"></a>1.8 小结</h3><ul><li>艺术书并不保证你读过之后能成为艺术家，只能告诉你其他艺术家用过的工具、技术和思维过程。</li><li>本书同样也不担保让你成为好程序员。它不担保能给你”代码感”。</li><li>它所能做的，只是展示好程序员的思维过程，还有他们使用的技巧、技术和工具。</li><li>你会看到好代码，也会看到糟糕的代码。你会的看到糟糕的代码如何转化为好代码。你会看到启发、规条和技巧的列表。</li><li>你会看到一个有一个的例子。但最终结果取决于你自己。  </li><li>最重要的是多练习。</li><li>Practice makes perfect。（熟能生巧）  </li><li>无他，唯手熟尔。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程艺术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程艺术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《管理者一定会遇到的那些事》学习笔记</title>
      <link href="/2021/08/29/guan-li-zhe-yi-ding-hui-yu-dao-de-na-xie-shi-xue-xi-bi-ji/"/>
      <url>/2021/08/29/guan-li-zhe-yi-ding-hui-yu-dao-de-na-xie-shi-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="《管理者一定会遇到的那些事》学习笔记"><a href="#《管理者一定会遇到的那些事》学习笔记" class="headerlink" title="《管理者一定会遇到的那些事》学习笔记"></a>《管理者一定会遇到的那些事》学习笔记</h2><blockquote><p>原文地址：《极客时间》<br>管理者一定会遇到的那些事 沈剑 | 到家集团技术委员会主席 / 快狗打车 CTO<br>文章：<a href="https://time.geekbang.org/column/article/315817">https://time.geekbang.org/column/article/315817</a><br>视频：<a href="https://time.geekbang.org/opencourse/detail/100065901">https://time.geekbang.org/opencourse/detail/100065901</a></p></blockquote><h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><ul><li>不要成为你讨厌的那种leader</li></ul><h3 id="第一，当员工不符合预期的时候，我们是给他机会，还是-Fire-Fast-呢？"><a href="#第一，当员工不符合预期的时候，我们是给他机会，还是-Fire-Fast-呢？" class="headerlink" title="第一，当员工不符合预期的时候，我们是给他机会，还是 Fire Fast 呢？"></a>第一，当员工不符合预期的时候，我们是给他机会，还是 Fire Fast 呢？</h3><ul><li>找到员工不符合预期的原因<ul><li>第一，他的能力确实没有达到。</li><li>第二，判断他是否被放在了正确的岗位上。</li><li>最后，看看是否真的是工作态度有问题且长期不能改变。</li></ul></li><li>不要轻易放弃任何一个队友<ul><li>发现问题，至少要给对方 1~2 次的机会。</li></ul></li><li>案例：作者在校招入职百度时，因为从windows转后端遇到重重困难导致转正困难，而leader给了机会和充分的帮助。</li><li>总结下来主要就是2点：<ul><li>第一，当员工不符合预期的时候，Leader 应该先找下原因，看看是他的能力没有达到，还是说他没有被放在正确的岗位上。</li><li>第二，不要轻易放弃任何一个队友，作为 Leader，应该给予下属一些指导，而且至少要给他 1~2 次机会。</li></ul></li></ul><h3 id="第二，当员工不给力的时候，你需不需要手把手地去指导他呢？"><a href="#第二，当员工不给力的时候，你需不需要手把手地去指导他呢？" class="headerlink" title="第二，当员工不给力的时候，你需不需要手把手地去指导他呢？"></a>第二，当员工不给力的时候，你需不需要手把手地去指导他呢？</h3><ul><li>作为 Leader，在带团队的过程中，言传身教是很有必要的。 </li><li>Leader 的核心职责是要把下属变成更牛的人，同时要给下属安全感，让他们有勇气展开拳脚做事。</li><li>案例：作者在百度工作近2年时，负责核心模块chatserver，遇到一个丢消息的疑难问题排查，leader手把手画架构图、指导排查。</li></ul><h3 id="第三，你明明是为了员工好，但在与他沟通的过程中却谈崩了，这个时候应该怎么办？"><a href="#第三，你明明是为了员工好，但在与他沟通的过程中却谈崩了，这个时候应该怎么办？" class="headerlink" title="第三，你明明是为了员工好，但在与他沟通的过程中却谈崩了，这个时候应该怎么办？"></a>第三，你明明是为了员工好，但在与他沟通的过程中却谈崩了，这个时候应该怎么办？</h3><ul><li>在技术探讨的过程中，应该相互吸取对方方案的优点，规避掉缺点，这样整个架构才会越来越合理，双方的架构能力也会不断提升。</li><li>第一，在沟通的过程中，Leader 有义务引导员工表达出自己的意见，切忌打压对方。</li><li>第二，注意自己的表达方式，不可采用强势的反问句。</li><li>第三，过去的经验未必 100% 正确，任何脱离业务的架构设计都是耍流氓，并没有一成不变、普适的架构方案。</li></ul><h3 id="第四，你把组内的一切细节都安排好了，自己却很累，应该怎么办？"><a href="#第四，你把组内的一切细节都安排好了，自己却很累，应该怎么办？" class="headerlink" title="第四，你把组内的一切细节都安排好了，自己却很累，应该怎么办？"></a>第四，你把组内的一切细节都安排好了，自己却很累，应该怎么办？</h3><ul><li>第一，作为 Leader，不必事必躬亲，而是要授人以渔。如果你把所有的细节都打理得妥妥当当，反而不利于下属获得提升。你应该把自己牛的地方抽象出方法论，传授给底下的同学，而你担任的也只是一个导师、教练这样的角色。</li><li>第二，不要拿下属的成果去邀功，要将团队内有成绩的人推向前台。同时，不要推下属出去背锅，这是我心中最为不齿的管理者。你作为 Leader，如果连锅都不敢背的话，还指望有人跟着你干吗？</li></ul><h3 id="第五，我们在工作过程中经常会碰到-Boss-需求，具体应该如何应对呢？"><a href="#第五，我们在工作过程中经常会碰到-Boss-需求，具体应该如何应对呢？" class="headerlink" title="第五，我们在工作过程中经常会碰到 Boss 需求，具体应该如何应对呢？"></a>第五，我们在工作过程中经常会碰到 Boss 需求，具体应该如何应对呢？</h3><ul><li>第一，要设置优先级机制，并根据公司的战略、方向制定项目优先级。</li><li>第二，要有优先级调整机制，而且大家一定要达成共识。</li><li>第三，对于重点项目可以冲刺，但不要采用“运动式”加班。</li><li>第四，不要随意找负责人改变优先级。</li></ul><h3 id="第六，明明团队很优秀，但最终的评优结果却并不符合预期，应该怎么办？"><a href="#第六，明明团队很优秀，但最终的评优结果却并不符合预期，应该怎么办？" class="headerlink" title="第六，明明团队很优秀，但最终的评优结果却并不符合预期，应该怎么办？"></a>第六，明明团队很优秀，但最终的评优结果却并不符合预期，应该怎么办？</h3><ul><li>第一，有自下而上，投票，大家提名、老板拍板这 3 种决策机制，选择决策机制的时候，要根据实际情况来做判断。</li><li>第二，团队 Leader 不能因为评优结果就改变对员工的看法。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/postimages/tech-management-shenjian-img.png" alt="img.png"></p>]]></content>
      
      
      <categories>
          
          <category> 技术管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《编程一万小时的反思》阅读交流</title>
      <link href="/2021/08/16/theartofcode/bian-cheng-yi-wan-xiao-shi-de-fan-si-yue-du-jiao-liu/"/>
      <url>/2021/08/16/theartofcode/bian-cheng-yi-wan-xiao-shi-de-fan-si-yue-du-jiao-liu/</url>
      
        <content type="html"><![CDATA[<h2 id="《编程一万小时的反思》阅读心得分享"><a href="#《编程一万小时的反思》阅读心得分享" class="headerlink" title="《编程一万小时的反思》阅读心得分享"></a>《编程一万小时的反思》阅读心得分享</h2><blockquote><p>原文参见：<br>英文原文：<a href="https://matt-rickard.com/reflections-on-10-000-hours-of-programming/">https://matt-rickard.com/reflections-on-10-000-hours-of-programming/</a><br>中文译文：<a href="https://www.oschina.net/news/154219/reflections-on-10000-hours-of-programming">https://www.oschina.net/news/154219/reflections-on-10000-hours-of-programming</a></p></blockquote><p>近期认真阅读了一下 Matt.Rickard 总结的《编程一万小时的反思》， 并且和几位同学进行了一些交流。</p><p>把我们交流的一些非常有共鸣的点简单总结如下。</p><h3 id="核心要点"><a href="#核心要点" class="headerlink" title="核心要点"></a>核心要点</h3><h5 id="官方文档和源码是最重要的，如果二者有冲突，以源码为准。"><a href="#官方文档和源码是最重要的，如果二者有冲突，以源码为准。" class="headerlink" title="官方文档和源码是最重要的，如果二者有冲突，以源码为准。"></a>官方文档和源码是最重要的，如果二者有冲突，以源码为准。</h5><ul><li>原文内容：阅读源代码常常会比在 Stack Overflow 上更快找到答案。</li><li>Browsing the source is almost always faster than finding an answer on StackOverflow.</li><li>原文内容：从最好的资料中进行学习（这里 Matt 举例称他在学习 Go 时阅读了标准库）。</li><li>Only learn from the best. So when I was learning Go, I read the standard library.</li><li>对于使用到的各种软件和工具，尽量多看官方文档、少看他人解读的”二手资料”</li><li>请记住：源码一定是对的；如果发现资料/书籍有问题，请看源码；如果发现官方文档有问题，请看源码。</li></ul><h5 id="代码如果不好写单元测试或者不好测试，一般代码可能也不够好。"><a href="#代码如果不好写单元测试或者不好测试，一般代码可能也不够好。" class="headerlink" title="代码如果不好写单元测试或者不好测试，一般代码可能也不够好。"></a>代码如果不好写单元测试或者不好测试，一般代码可能也不够好。</h5><ul><li>原文内容：如果代码看起来很丑，那很可能是一个严重的错误。</li><li>If it looks ugly, it is most likely a terrible mistake.  </li><li>如果代码不好写测试，往往也是设计或者实现上还有优化空间（非绝对）。</li></ul><h5 id="KISS原则：Keep-it-Simple-and-Stupid"><a href="#KISS原则：Keep-it-Simple-and-Stupid" class="headerlink" title="KISS原则：Keep it Simple and Stupid."></a>KISS原则：Keep it Simple and Stupid.</h5><ul><li>原文内容：尽可能多地删除代码。</li><li>Delete as much code as you can.  </li><li>原文内容：简单往往是最难的。</li><li>Simple is hard. </li><li>尽量保持代码简单、可读性强，不要炫技、如果可能尽量不要用复杂方案。</li><li>每多一行代码，就多一个出错的可能性。所以可要可不要的代码就不要。</li><li>建议阅读《Unix编程艺术》，微信读书有电子版、或者可以买纸质版。（豆瓣评分9.0）</li></ul><h5 id="最好的注释即代码。"><a href="#最好的注释即代码。" class="headerlink" title="最好的注释即代码。"></a>最好的注释即代码。</h5><ul><li>原文：如果必须编写不是文档字符串 (docstring) 的注释，则应该考虑对这段代码进行重构。</li><li>If you have to write a comment that isn’t a docstring, it should probably be refactored. Every new line of comments increases this probability. (For a more nuanced take, the Linux Kernel Documentation)</li><li>只添加必要的注释；千万不要觉得注释越多越好，阅读注释也有成本。</li><li>如果你的代码可读性足够强，那么大部分地方不需要注释；此外，维护注释也需要成本，容易出现改了代码忘改注释的情况。</li></ul><h5 id="命名非常重要，命名做好了，代码已经成功了一半。"><a href="#命名非常重要，命名做好了，代码已经成功了一半。" class="headerlink" title="命名非常重要，命名做好了，代码已经成功了一半。"></a>命名非常重要，命名做好了，代码已经成功了一半。</h5><ul><li>原文：正确命名变量，这也是一门艺术。</li><li>Name variables correctly. Again, an art.  </li><li>Bob大叔在《代码整洁之道》一书中第2章即花大篇幅介绍”有意义的命名”，所以命名的重要性可见一斑，建议阅读该章内容。</li><li>命名要点包括：<ul><li>名副其实</li><li>避免误导</li><li>做有意义的区分</li><li>使用读得出来的名称</li><li>使用可搜索的名称</li><li>避免使用编码</li><li>避免思维映射</li><li>类名、方法名分别有约定</li><li>每个概念对应一个词</li><li>别抖机灵、别用双关语</li><li>使用解决方案领域名称、使用源自所涉问题领域的名称</li><li>添加有意义的语境、不要添加没用的语境</li></ul></li><li>我们不要认为自己只是个码农，而应该是个”代码艺术家”，要对代码之美有追求。</li></ul><h5 id="努力成为10倍工程师。"><a href="#努力成为10倍工程师。" class="headerlink" title="努力成为10倍工程师。"></a>努力成为10倍工程师。</h5><ul><li>原文：部分程序员的效率是其他程序员的 10 倍。</li><li>Some programmers are 10x more efficient than others. I know because I’ve been both a 10x programmer and a -1x programmer.</li><li>原文：成为 10 倍程序员与 10 倍员工这两者之间没有相关性（或许是负相关）。</li><li>There’s no correlation between being a 10x programmer and a 10x employee (maybe a negative one).</li><li>虽然是否真的存在10倍工程师还有争议，但是此处重在强调应该成为一个专业的、有职业素养的优秀程序员。</li><li>可以搜索”10倍程序员”看看相关内容。</li><li>建议阅读 Bob 大叔”整洁之道四部曲”：《Clean Code》、《Clean Coder》、《Clean Architecture》、《Clean Agile》</li><li>这4本书直译过来叫做：代码整洁之道、程序员整洁之道（实际中文译本叫做：《代码整洁之道：程序员的职业素养》）、架构整洁之道、敏捷整洁之道。</li><li>针对如何成为一个有职业素养的专业程序员，尤其推荐首先阅读《Clean Coder》。</li></ul><h5 id="防御性编程：不要相信任何输入，所有的输入都要设想可能是非法输入。"><a href="#防御性编程：不要相信任何输入，所有的输入都要设想可能是非法输入。" class="headerlink" title="防御性编程：不要相信任何输入，所有的输入都要设想可能是非法输入。"></a>防御性编程：不要相信任何输入，所有的输入都要设想可能是非法输入。</h5><ul><li>原文：好的 API 易于使用且难以误用。</li><li>Good APIs are easy to use and hard to misuse.  </li><li>原文：避免多层嵌套条件。</li><li>Avoid nesting conditionals deeply. Have common sense about your conditional tests and naming convention.  </li><li>好的 API 易于使用：命名合理、可读性强，输入输出设置合理且扩展性好。</li><li>好的 API 难以误用：针对各种可能的误用情况进行必要校验并给出可读性强的报错信息提示。</li></ul><h5 id="代码与配置分离，一般不要硬编码"><a href="#代码与配置分离，一般不要硬编码" class="headerlink" title="代码与配置分离，一般不要硬编码"></a>代码与配置分离，一般不要硬编码</h5><ul><li>原文：配置七边形（Matt 自创的术语）从硬编码值开始，到环境变量、CLI Flag、配置文件、模板化配置文件、DSL、通用 bash 脚本，再到硬编码值。开发者应了解这个七边形中的各个位置。</li><li>The configuration cycle goes from hardcoded values to environment variables, to CLI flags, to a configuration file, to a templated configuration file, to a DSL, to a generic bash script, and back to hardcoded values. Know where you are on this Heptagon of Configuration.</li><li>可以采取的策略包括：使用常量、使用环境变量、使用配置中心等。</li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>要成为一个优秀的、有职业素养的专业程序员绝非易事。</li><li>作为一名程序员，应该对代码之美有高追求。</li><li>为了写出优雅、具有美感的代码和成为代码艺术家，推荐阅读：<ul><li>《Unix编程艺术》 </li><li>《Clean Coder》</li><li>《Clean Code》</li><li>《Clean Architecture》</li><li>《Clean Agile》</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程艺术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程艺术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo在matery主题下集成utteranc评论插件</title>
      <link href="/2021/08/15/hexo/hexo-zai-matery-zhu-ti-xia-ji-cheng-utteranc-ping-lun-cha-jian/"/>
      <url>/2021/08/15/hexo/hexo-zai-matery-zhu-ti-xia-ji-cheng-utteranc-ping-lun-cha-jian/</url>
      
        <content type="html"><![CDATA[<h2 id="hexo在matery主题下集成utteranc评论插件"><a href="#hexo在matery主题下集成utteranc评论插件" class="headerlink" title="hexo在matery主题下集成utteranc评论插件"></a>hexo在matery主题下集成utteranc评论插件</h2><p>本博客使用的是hexo搭建，主题选择的是matery。（感兴趣的可参考第一篇博客。）</p><p>matery主题的介绍和使用详见：<a href="https://github.com/blinkfox/hexo-theme-matery">https://github.com/blinkfox/hexo-theme-matery</a>.</p><p>我选择该主题的主要原因是比较喜欢其界面风格、整体感觉比较优雅，且功能较为完整。<br>在此感谢该主题作者的分享 :)</p><p>为了能够和各位更好地交流，希望引入评论插件。找了一圈以后，想要用 utteranc 这个工具：<br><a href="https://utteranc.es/">https://utteranc.es</a>       (<a href="https://github.com/utterance/utterances">https://github.com/utterance/utterances</a>)</p><p>然而在网上找了下集成的方法，发现基本上只介绍了hexo下的fluid主题和next，对于matery没有找到介绍。</p><p>所以这里针对matery主题如何集成 utteranc插件做一下简单分享。</p><h1 id="前置准备：准备一个代码仓库并配置好-utteranc"><a href="#前置准备：准备一个代码仓库并配置好-utteranc" class="headerlink" title="前置准备：准备一个代码仓库并配置好 utteranc"></a>前置准备：准备一个代码仓库并配置好 utteranc</h1><p>该部分内容，网上有详细教程，本文不再赘述。（直接google或者百度搜索 hexo 集成 utteranc）</p><p>可以参考：<a href="https://www.jianshu.com/p/785d727810b3">https://www.jianshu.com/p/785d727810b3</a></p><p>在此，也对该文章的作者表示感谢 :)</p><h1 id="在自己的博客中集成-utteranc"><a href="#在自己的博客中集成-utteranc" class="headerlink" title="在自己的博客中集成 utteranc"></a>在自己的博客中集成 utteranc</h1><blockquote><p>注意以下前置条件：</p><ol><li>已经有一个博客系统，基于hexo搭建，使用matery主题。</li><li>完成前述步骤：有一个公开的github仓库，用来支持评论。（因为utteranc的评论实际上是会记录到github仓库的issue中。）</li><li>完成前述步骤：配置好 utteranc，并复制其提供的一段js代码，类似下面这样：</li></ol></blockquote><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"https://utteranc.es/client.js"</span>        repo<span class="token operator">=</span><span class="token string">"liukgg/comment-utterances"</span>        issue<span class="token operator">-</span>term<span class="token operator">=</span><span class="token string">"pathname"</span>        theme<span class="token operator">=</span><span class="token string">"github-light"</span>        crossorigin<span class="token operator">=</span><span class="token string">"anonymous"</span>        async<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><p>接下来，正式开始在hexo搭建的博客、且选择 matery 主题的情况下，集成utteranc 以实现评论功能。</p><h3 id="主要改动：修改-matery-主题中的相关文件"><a href="#主要改动：修改-matery-主题中的相关文件" class="headerlink" title="主要改动：修改 matery 主题中的相关文件"></a>主要改动：修改 matery 主题中的相关文件</h3><p>改动文件目录基本都在这个下面： themes/hexo-theme-matery/</p><h5 id="改动第1个文件：-themes-hexo-theme-matery-config-yml"><a href="#改动第1个文件：-themes-hexo-theme-matery-config-yml" class="headerlink" title="改动第1个文件： themes/hexo-theme-matery/_config.yml"></a>改动第1个文件： themes/hexo-theme-matery/_config.yml</h5><p>加入以下配置：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># utteranc config, default disabled</span><span class="token comment"># utteranc 评论模块的配置，默认为不激活</span><span class="token key atrule">utteranc</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>该配置的目的主要是和 matery 原来的引入评论插件保持一致，保持灵活性。</p><h5 id="改动第2个文件-themes-hexo-theme-matery-layout-partial-post-detail-ejs"><a href="#改动第2个文件-themes-hexo-theme-matery-layout-partial-post-detail-ejs" class="headerlink" title="改动第2个文件: themes/hexo-theme-matery/layout/_partial/post-detail.ejs"></a>改动第2个文件: themes/hexo-theme-matery/layout/_partial/post-detail.ejs</h5><p>  加入以下配置(在165行左右，参考其他评论插件的代码位置)：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>theme<span class="token punctuation">.</span>utteranc <span class="token operator">&amp;&amp;</span> theme<span class="token punctuation">.</span>utteranc<span class="token punctuation">.</span>enable<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">%</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> <span class="token function">partial</span><span class="token punctuation">(</span><span class="token string">'_partial/utteranc'</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token punctuation">}</span> <span class="token operator">%</span><span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>该处改动的目的是为了在所有博客文章中统一在底部加入一个评论模块，这个改动很关键、所放位置也很重要。<br>post-detail.ejs 是所有博客文章渲染的模板，因此需要在此处统一改动。</p><h5 id="改动第3个文件：新增一个文件-themes-hexo-theme-matery-layout-partial-utteranc-ejs"><a href="#改动第3个文件：新增一个文件-themes-hexo-theme-matery-layout-partial-utteranc-ejs" class="headerlink" title="改动第3个文件：新增一个文件 themes/hexo-theme-matery/layout/_partial/utteranc.ejs"></a>改动第3个文件：新增一个文件 themes/hexo-theme-matery/layout/_partial/utteranc.ejs</h5><p>该文件内容如下：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"card"</span> data<span class="token operator">-</span>aos<span class="token operator">=</span><span class="token string">"fade-up"</span><span class="token operator">&gt;</span>    <span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">"utteranc-container"</span> <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"card-content"</span><span class="token operator">&gt;</span>        <span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"https://utteranc.es/client.js"</span>                repo<span class="token operator">=</span><span class="token string">"liukgg/comment-utterances"</span>                issue<span class="token operator">-</span>term<span class="token operator">=</span><span class="token string">"pathname"</span>                theme<span class="token operator">=</span><span class="token string">"github-light"</span>                crossorigin<span class="token operator">=</span><span class="token string">"anonymous"</span>                async<span class="token operator">&gt;</span>        <span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该文件就是评论模块的真实内容，核心内容是在前述步骤中复制的 utteranc 配置。<br>此外，外面加了2个div模块，主要是为了在页面展示的时候加入一个方块、和文章风格保持基本一致。<br>（对于这个div里的样式具体是如何生效的，没有做过多探究，基本上是参考另一个评论插件 gitalk 的代码。）</p><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>以上，就已经集成好了utteranc评论。重新启动 hexo server，刷新页面后，就能在文章下放看到评论模块了。</p><p>效果可以参考：<a href="http://luckliu.xyz/2021/08/01/hello-world/">http://luckliu.xyz/2021/08/01/hello-world/</a></p><p>所有的留言都会出现在前述配置的github 仓库中，可以参考：<a href="https://github.com/liukgg/comment-utterances/issues">https://github.com/liukgg/comment-utterances/issues</a></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>如果博客中还有单独的一个留言板模块，那么还需要改动一下这个文件： themes/hexo-theme-matery/layout/contact.ejs</p><p>加入以下代码(136行附近)：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>theme<span class="token punctuation">.</span>utteranc <span class="token operator">&amp;&amp;</span> theme<span class="token punctuation">.</span>utteranc<span class="token punctuation">.</span>enable<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">%</span><span class="token operator">&gt;</span>    <span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> <span class="token function">partial</span><span class="token punctuation">(</span><span class="token string">'_partial/utteranc'</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token punctuation">}</span> <span class="token operator">%</span><span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>重启服务 hexo server，刷新页面以后，就能看到留言板也能留言评论了。</p><p>效果可以参考：<a href="http://luckliu.xyz/contact">http://luckliu.xyz/contact</a></p><p>如有问题，欢迎在我以上的博客留言板中留言交流。</p>]]></content>
      
      
      <categories>
          
          <category> Reference </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo-Matery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaCoreTech05-类继承的设计技巧</title>
      <link href="/2021/08/09/javacoretech/javacoretech-05-lei-ji-cheng-de-she-ji-ji-qiao/"/>
      <url>/2021/08/09/javacoretech/javacoretech-05-lei-ji-cheng-de-she-ji-ji-qiao/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Java核心技术 卷I 第5章 5.8</p></blockquote><p>在本章的最后， 给出一些对设计继承关系很有帮助的建议。</p><ol><li>将公共操作和域放在超类<br>这就是为什么将姓名域放在 Person 类中， 而没有将它放在 Employee 和 Student 类中的原因。 2. 不要使用受保护的域<br>有些程序员认为， 将大多数的实例域定义为 protected 是一个不错的主意， 只有这样， 子<br>e.printStackTraceO ;<br>类才能够在需要的时候直接访问它们。 然而， protected 机制并不能够带来更好的保护， 其原</li></ol><p>因主要有两点。 第一， 子类集合是无限制的， 任何一个人都能够由某个类派生一个子类， 并 编写代码以直接访问 protected 的实例域， 从而破坏了封装性。 第二， 在 Java 程序设计语言 中， 在同一个包中的所有类都可以访问 proteced 域， 而不管它是否为这个类的子类。<br>不过， protected 方法对于指示那些不提供一般用途而应在子类中重新定义的方法很有用。 3.使用继承实现“ is-a”关系 使用继承很容易达到节省代码的目的，但有时候也被人们滥用了。例如， 假设需要定义<br>一个钟点工类。 钟点工的信息包含姓名和雇佣日期， 但是没有薪水。 他们按小时计薪， 并且 不会因为拖延时间而获得加薪- 这似乎在诱导人们由 Employee 派生出子类 Contractor, 然后 再增加一个 hourlyWage 域。<br>public class Contractor extends Employee {<br>private double hourlyWage; }<br>这并不是一个好主意。 因为这样一来， 每个钟点;o橡中都包含了薪水和计时工资这两个域。 在实现打印支票或税单方法耐候， 会带来诞的麻烦， 并且与不采用继承， 会多写很制戈码。<br>钟点工与雇员之间不属于“ is-a” 关系。钟点工不是特殊的雇员。<br>4. 除非所有继承的方法都有意义， 否则不要使用继承<br>   假设想编写一个 Holiday 类 3 毫无疑问， 每个假日也是一日， 并且一日可以用 Gregorian<br>   Calendar 类的实例表示， 因此可以使用继承。 class Holiday extends CregorianCalendar { . . , }<br>   很遗憾， 在继承的操作中， 假日集不是封闭的。 在 GregorianCalendar 中有一个公有方法 add, 可以将假日转换成非假日:<br>   Holiday Christmas; Christmas.add(Calendar.DAY_OF_MONTH, 12);<br>   因此， 继承对于这个例子来说并不太适宜。<br>   需要指出， 如果扩展 LocalDate 就不会出现这个问题。 由于这个类是不可变的， 所以没<br>   有任何方法会把假日变成非假日。<br>5. 在覆盖方法时， 不要改变预期的行为<br>   置换原则不仅应用于语法， 而且也可以应用于行为， 这似乎更加重要。 在覆盖一个方法<br>   的时候， 不应该毫无原由地改变行为的内涵。就这一点而言， 编译器不会提供任何帮助， 即 编译器不会检查重新定义的方法是否有意义。例如，可以重定义Holiday类中add方法“ 修 正” 原方法的问题， 或什么也不做， 或抛出一个异常， 或继续到下一个假日。<br>   然而这些都违反了置换原则。 语句序列<br>   int dl = x.get(Calendar.DAY_OF_MONTH); x.add(Calendar.DAY_OF_MONTH, 1);<br>   int d2 = x.get(Calendar.DAY_OF_HONTH); System.out.println(d2 -dl);<br>   不管 x 属于 GregorianCalendar 类， 还是属于 Holiday 类， 执行上述语句后都应该得到预期的 行 为。<br>   当然， 这样可能会引起某些争议。人们可能就预期行为的含义争论不休。 例如， 有些人 争论说， 置换原则要求 Manager.equals 不处理 bonus 域， 因为 Employee.equals 没有它。 实际 上， 凭空讨论这些问题毫无意义。 关键在于， 在覆盖子类中的方法时， 不要偏离最初的设计 想法。<br>6. 使用多态， 而非类型信息<br>   无论什么时候， 对于下面这种形式的代码<br>   if (x isoftype1)<br>   actioniM <br>   else if (x isoftype2)<br>   actioniM; 都应该考虑使用多态性。<br>   action, 与 3如 0112 表示的是相同的概念吗? 如果是相同的概念， 就应该为这个概念定义一 个方法， 并将其放置在两个类的超类或接口中， 然后， 就可以调用<br>   X.action0<br>   以便使用多态性提供的动态分派机制执行相应的动作。 使用多态方法或接口编写的代码比使用对多种类型进行检测的代码更加易于维护和扩展。 7. 不要过多地使用反射<br>   反射机制使得人们可以通过在运行时查看域和方法， 让人们编写出更具有通用性的程序。<br>   这种功能对于编写系统程序来说极其实用， 但是通常不适于编写应用程序。 反射是很脆弱的， 即编译器很难帮助人们发现程序中的错误， 因此只有在运行时才发现错误并导致异常。<br>   现在你已经了解了 Java 支持面向对象编程的基础内容: 类、继承和多态。下一章中我们 将介绍两个髙级主题: 接口和 lambda 表达式， 它们对于有效地使用 Java 非常重要。  </p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaCoreTech-04-类设计技巧</title>
      <link href="/2021/08/08/javacoretech/javacoretech-04-lei-she-ji-ji-qiao/"/>
      <url>/2021/08/08/javacoretech/javacoretech-04-lei-she-ji-ji-qiao/</url>
      
        <content type="html"><![CDATA[<h2 id="类设计技巧"><a href="#类设计技巧" class="headerlink" title="类设计技巧"></a>类设计技巧</h2><blockquote><p>参考： Java核心技术 卷I 第4章 4.10<br>在学习书籍的基础上，结合作者自身在多个项目中的实际经验、加入了一些自己的理解和工程化的实际经验总结。<br>面向对象的三大特征：封装、继承、多态<br>本章介绍了 Java 这种面向对象语言的有关对象和类的基础知识。<br>为了真正做到面向对象，程序设计语言还必须支持继承和多态。<br>Java 提供了对这些特性的支持，具体内容将在下一章中介绍。</p></blockquote><p>Java核心技术一书中简单地介绍了几点类设计的技巧。应用这些技巧可以使你设计的类更能得到专业OOP圈子的认可。<br>（注：OOP 是指 Object-Oriented Programming，即 面向对象编程）。</p><h3 id="1-一定要保证数据私有"><a href="#1-一定要保证数据私有" class="headerlink" title="1. 一定要保证数据私有"></a>1. 一定要保证数据私有</h3><p>  这是最重要的; 绝对不要破坏封装性。</p><p>  有时候， 需要编写一个访问器方法或更改器方法， 但是最好还是保持实例域的私有性。</p><p>  很多惨痛的经验告诉我们， 数据的表示形式很可能会改变， 但它们的使用方式却不会经常发生变化。<br>  当数据保持私有时， 它们的表示形式的变化不会对类的使用者产生影响， 即使出现 bug 也易于检测。</p><blockquote><p>实际经验：<br>类设计：字段要隐藏。<br>因为会有检验或者触发逻辑，比如检验邮箱是否符合正则表达式，检验id是否唯一等等。<br>触发逻辑比如凡是订单状态变化就要发消息通知等<br>如果外界直接改字段值，可能就会绕过校验或者必要的触发逻辑，从而导致业务逻辑错误或非法数据、甚至导致安全问题。</p></blockquote><h3 id="2-一定要对数据初始化"><a href="#2-一定要对数据初始化" class="headerlink" title="2. 一定要对数据初始化"></a>2. 一定要对数据初始化</h3><p>   Java 不对局部变量进行初始化， 但是会对对象的实例域进行初始化。<br>   最好不要依赖于系 统的默认值， 而是应该显式地初始化所有的数据， 具体的初始化方式可以是提供默认值， 也可以是在所有构造器中设置默认值。</p><h3 id="3-不要在类中使用过多的基本类型"><a href="#3-不要在类中使用过多的基本类型" class="headerlink" title="3. 不要在类中使用过多的基本类型"></a>3. 不要在类中使用过多的基本类型</h3><p>   就是说， 用其他的类代替多个相关的基本类型的使用。这样会使类更加易于理解且易于 修改。例如， 用一个称为 Address 的新的类替换一个 Customer 类中以下的实例域:<br>   private String street; private String city; private String state; private int zip;<br>   这样， 可以很容易处理地址的变化， 例如， 需要增加对国际地址的处理。</p><h3 id="4-不是所有的域都需要独立的域访问器和域更改器"><a href="#4-不是所有的域都需要独立的域访问器和域更改器" class="headerlink" title="4. 不是所有的域都需要独立的域访问器和域更改器"></a>4. 不是所有的域都需要独立的域访问器和域更改器</h3><p>   或许， 需要获得或设置雇员的薪金。 而一旦构造了雇员对象， 就应该禁止更改雇用日<br>   期， 并且在对象中， 常常包含一些不希望别人获得或设置的实例域， 例如， 在 Address 类中， 存放州缩写的数组。</p><h3 id="5-将职责过多的类进行分解"><a href="#5-将职责过多的类进行分解" class="headerlink" title="5. 将职责过多的类进行分解"></a>5. 将职责过多的类进行分解</h3><p>   这样说似乎有点含糊不清， 究竟多少算是“ 过多” ? 每个人的看法不同。<br>   但是， 如果明 显地可以将一个复杂的类分解成两个更为简单的类， 就应该将其分解<br>   (但另一方面， 也不要走极端。 设计 10 个类， 每个类只有一个方法， 显然有些矫枉过正了)。</p><p>   下面是一个反面的设计示例。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CardDeck</span> <span class="token comment">// bad design </span><span class="token punctuation">{</span>   <span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> value<span class="token punctuation">;</span>   <span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> suit<span class="token punctuation">;</span>   <span class="token keyword">public</span> <span class="token class-name">CardDeck</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">}</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> shuffle0 <span class="token punctuation">{</span>•••<span class="token punctuation">}</span>   <span class="token keyword">public</span> <span class="token keyword">int</span> getTopValueO <span class="token punctuation">{</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">}</span>   <span class="token keyword">public</span> <span class="token keyword">int</span> getTopSuitO <span class="token punctuation">{</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实际上， 这个类实现了两个独立的概念: 一副牌(含有 shuffle 方法和 draw 方法)和一 张牌(含有查看面值和花色的方法)。另外，引入一个表示单张牌的 Card类。现在有两个类， 每个类完成自己的职责:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CardDeck</span><span class="token punctuation">{</span>   <span class="token keyword">private</span> <span class="token class-name">Card</span><span class="token punctuation">[</span><span class="token punctuation">]</span> cards<span class="token punctuation">;</span>   <span class="token keyword">public</span> <span class="token class-name">CardDeckO</span> <span class="token punctuation">{</span> • <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">}</span> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">shuffle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">}</span> <span class="token keyword">public</span> <span class="token class-name">Card</span> getTopO <span class="token punctuation">{</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">}</span> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Card</span> <span class="token punctuation">{</span>   <span class="token keyword">private</span> <span class="token keyword">int</span> value<span class="token punctuation">;</span> <span class="token keyword">private</span> <span class="token keyword">int</span> suit<span class="token punctuation">;</span>   <span class="token keyword">public</span> <span class="token class-name">Card</span><span class="token punctuation">(</span><span class="token keyword">int</span> aValue<span class="token punctuation">,</span> <span class="token keyword">int</span> aSuit<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">}</span> <span class="token keyword">public</span> <span class="token keyword">int</span> getValueO <span class="token punctuation">{</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">}</span>   <span class="token keyword">public</span> <span class="token keyword">int</span> getSuitO <span class="token punctuation">{</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-类名和方法名要能够体现它们的职责"><a href="#6-类名和方法名要能够体现它们的职责" class="headerlink" title="6. 类名和方法名要能够体现它们的职责"></a>6. 类名和方法名要能够体现它们的职责</h3><p>   与变量应该有一个能够反映其含义的名字一样， 类也应该如此(在标准类库中， 也存在 着一些含义不明确的例子， 如: Date 类实际上是一个用于描述时间的类 )。<br>   命名类名的良好习惯是采用一个名词(Order)、 前面有形容词修饰的名词( RushOrder) 或动名词(有“ -ing”后缀)修饰名词(例如，BillingAddress)。<br>   对于方法来说，习惯是访问 器方法用小写 get 开头 ( getSalary ), 更改器方法用小写的 set 开头(setSalary )</p><h3 id="7-优先使用不可变的类-—"><a href="#7-优先使用不可变的类-—" class="headerlink" title="7. 优先使用不可变的类 —"></a>7. 优先使用不可变的类 —</h3><p>   LocalDate 类以及 java.time 包中的其他类是不可变的 没有方法能修改对象的状态。<br>   类似 plusDays 的方法并不是更改对象， 而是返回状态已修改的新对象。</p><p>   更改对象的问题在于， 如果多个线程试图同时更新一个对象， 就会发生并发更改。<br>   其结果是不可预料的。 如果类是不可变的， 就可以安全地在多个线程间共享其对象。</p><p>   因此， 要尽可能让类是不可变的， 这是一个很好的想法。<br>   对于表示值的类， 如一个字符串或一个时间点， 这尤其容易。 计算会生成新值， 而不是更新原来的值。</p><p>   当然， 并不是所有类都应当是不可变的。<br>   如果员工加薪时让 raiseSalary 方法返回一个新 的 Employee 对象， 这会很奇怪。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaCoreTech-03-关于equals方法</title>
      <link href="/2021/08/08/javacoretech/javacoretech-03-guan-yu-equals-fang-fa/"/>
      <url>/2021/08/08/javacoretech/javacoretech-03-guan-yu-equals-fang-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="关于equals方法"><a href="#关于equals方法" class="headerlink" title="关于equals方法"></a>关于equals方法</h2><blockquote><p>参考 Java核心技术卷I 第5章 继承 5.2.2 equals方法<br>参考: <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html">https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html</a><br>参考: <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html">https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html</a></p></blockquote><h3 id="equals方法概述"><a href="#equals方法概述" class="headerlink" title="equals方法概述"></a>equals方法概述</h3><p>Object类中的euqals方法用于检测一个对象是否等于另外一个对象。</p><p>equals方法与 == 的区别与联系：</p><ul><li>== 用来判断两个变量是否相等，但是会根据数据类型有所区别：<ul><li>对于8种基础数据类型（byte、short、int、long、double、float、boolean、char）来说, == 是判断变量的数值是否相等。</li><li>对于引用类型，== 比较的是引用的地址是否相等。 </li></ul></li><li>Object.equals 里的内部实现，其实还是调用的==.</li><li>在自定义的类中一般会重写 Object.equals 方法，这时一般是根据业务逻辑来判断两个对象是否相等、而不是直接看两者是否是同一个对象。</li></ul><h3 id="阅读学习-Object-String-Array-类中equals方法源码"><a href="#阅读学习-Object-String-Array-类中equals方法源码" class="headerlink" title="阅读学习 Object, String, Array 类中equals方法源码"></a>阅读学习 Object, String, Array 类中equals方法源码</h3><p>根据Java API官方文档可知，Object.equals 方法实际上是判断两个对象是否是同一个对象。<br>也就是说，对于任意两个非空的对象（引用）x和y，当且仅当x和y指向同一个对象时才会返回true。<br>实际上，从源码可知， Object.equals 方法本质上就是判断 x == y。</p><p>结论：对于自定义的类，一般来说都需要重定义 equals 方法以覆盖Object.equals方法。<br>例如，比较常见的一种做法是，当类存在数据库且有主键ID的时候，经常会通过判断两个对象的ID是否相等来比较是否相等。</p><blockquote><p>String 类中重写了 equals 方法；<br>声明一个整型数组，查看其equals方法，会发现实际上就是 Object.equals 方法;<br>java.util.Arrays 中实现了多个不同参数的equals方法，例如 equals(int [] a, int[] b)，但是这已经和Object.equals方法有本质区别了。</p></blockquote><ul><li>以下为JDK 11中 Object.equals 方法的源码: (JDK 1.8 相同)<blockquote><p>参考: <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html">https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html</a></p></blockquote></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * reference： https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html *  * Indicates whether some other object is "equal to" this one. *  * The equals method for class Object implements the most discriminating possible equivalence relation on objects;  * that is, for any non-null reference values x and y,  * this method returns true if and only if x and y refer to the same object (x == y has the value true). *  * @param   obj   the reference object with which to compare. * @return  {@code true} if this object is the same as the obj *          argument; {@code false} otherwise. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Object</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>String.equals 方法源码：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">String</span>        <span class="token keyword">implements</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span><span class="token punctuation">,</span> <span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> <span class="token class-name">CharSequence</span> <span class="token punctuation">{</span><span class="token comment">/** * Compares this string to the specified object.  The result is {@code * true} if and only if the argument is not {@code null} and is a {@code * String} object that represents the same sequence of characters as this * object. * * &lt;p&gt;For finer-grained String comparison, refer to * {@link java.text.Collator}. * * @param  anObject *         The object to compare this {@code String} against * * @return  {@code true} if the given object represents a {@code String} *          equivalent to this string, {@code false} otherwise * * @see  #compareTo(String) * @see  #equalsIgnoreCase(String) */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> anObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> anObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>anObject <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token class-name">String</span> aString <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span>anObject<span class="token punctuation">;</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">coder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> aString<span class="token punctuation">.</span><span class="token function">coder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token function">isLatin1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token class-name">StringLatin1</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> aString<span class="token punctuation">.</span>value<span class="token punctuation">)</span>                    <span class="token operator">:</span> <span class="token class-name">StringUTF16</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> aString<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">StringLatin1</span> <span class="token punctuation">{</span>  <span class="token annotation punctuation">@HotSpotIntrinsicCandidate</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> value<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> other<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>value<span class="token punctuation">.</span>length <span class="token operator">==</span> other<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> value<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>value<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> other<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">// final class StringUTF16 类中实现类似，不再赘述。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="String-判断相等的方法与注意事项"><a href="#String-判断相等的方法与注意事项" class="headerlink" title="String 判断相等的方法与注意事项"></a>String 判断相等的方法与注意事项</h3><p>可以用equals方法检测两个字符串是否相等。例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span><span class="token class-name">String</span> t <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>s<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>s<span class="token punctuation">.</span><span class="token function">subString</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"hel"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>一定不要使用 == 运算符检测两个字符串是否相等！<br>这个运算符只能够确定两个字符串是否存放在同一个位置上。<br>当然，如果字符串在同一个位置上，它们必然相等。<br>但是，完全有可能将内容相同的多个字符串副本放置在不同的位置上。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> greeting <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>greeting <span class="token operator">==</span> <span class="token string">"hello"</span><span class="token punctuation">;</span> <span class="token comment">// true</span>greeting<span class="token punctuation">.</span><span class="token function">subString</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">"hel"</span><span class="token punctuation">;</span> <span class="token comment">//false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>说明：<br>如果虚拟机始终将相同的字符串共享，就可以使用==运算符检测是否相等。<br>但实际上只有字符串字面量是共享的，而 + 或 subString 等操作得到的字符串并不共享。<br>因此，千万不要使用 == 运算符测试字符串的相等性，以免在程序中出现这种最糟糕的bug，看起来这种bug就像随机产生的间歇性错误。</p><h3 id="自定义equals方法代码示例"><a href="#自定义equals方法代码示例" class="headerlink" title="自定义equals方法代码示例"></a>自定义equals方法代码示例</h3><p>为了更好地展示equals方法的定义，Employee类做了一些简化，只保留了id和name两个字段，<br>实际业务场景下一般会有更多字段，但是判断是否相等一般还是比较id。</p><p>从以下代码示例可以看出，实际上自定义类的equals方法定义和String中的equals方法定义是类似的。<br>因此，JDK中实际上有大量优秀源码实现，我们可以经常去探索和学习。<br>例如，除了 String.equals 方法，还有一个很值得学习的是 Arrays.sort方法，里面对于排序算法的选择和实现很精巧、值得推敲和学习。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token punctuation">{</span>  <span class="token keyword">private</span>  <span class="token keyword">int</span> id<span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">,</span> <span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span> id <span class="token operator">=</span> id<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> otherObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> otherObject<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>otherObject <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> otherObject<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token class-name">Employee</span> other <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Employee</span><span class="token punctuation">)</span> otherObject<span class="token punctuation">;</span>    <span class="token keyword">return</span> id <span class="token operator">==</span> other<span class="token punctuation">.</span>id<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EmployeeTest</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">Employee</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Employee</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Employee</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a <span class="token operator">==</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false, a 和 b的id相等，所以根据我们的equals方法定义来看是相等的；但是==比较的是引用地址，由于a和b不是同一个对象，所以返回false</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a <span class="token operator">==</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="如何自定义equals方法"><a href="#如何自定义equals方法" class="headerlink" title="如何自定义equals方法"></a>如何自定义equals方法</h3><h5 id="Java语言规范要求"><a href="#Java语言规范要求" class="headerlink" title="Java语言规范要求"></a>Java语言规范要求</h5><p>Java语言规范要求equals方法具有以下特性：</p><ul><li> 1 ) 自反性: 对于任何非空引用 x, x.equals(x) 应该返回 true.</li><li> 2 ) 对称性: 对于任何引用 x 和 y, 当且仅当 y.equals(x) 返回 true, x.equals(y) 也应该返回 true。</li><li> 3 ) 传递性: 对于任何引用 x、 y 和 z, 如果 x.equals(y) 返 true， y.equals(z) 返回 true, x.equals(z) 也应该返回 true。</li><li> 4 ) 一致性: 如果 x 和 y 引用的对象没有发生变化， 反复调用 x.equals(y) 应该返回同样的结果。</li><li> 5 ) 对于任意非空引用 x, x.equals(null) 应该返回 false.</li></ul><p>  这些规则十分合乎情理， 从而避免了类库实现者在数据结构中定位一个元素时还要考虑调用 x.equals(y), 还是调用 y.equals(x) 的问题。</p><p>这些内容在 Object.euqals 方法的文档中也有提到：</p><blockquote><p><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html">https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html</a></p><p>public boolean equals(Object obj)<br>Indicates whether some other object is “equal to” this one.<br>The equals method implements an equivalence relation on non-null object references:</p><p>It is reflexive: for any non-null reference value x, x.equals(x) should return true.<br>It is symmetric: for any non-null reference values x and y, x.equals(y) should return true if and only if y.equals(x) returns true.<br>It is transitive: for any non-null reference values x, y, and z, if x.equals(y) returns true and y.equals(z) returns true, then x.equals(z) should return true.<br>It is consistent: for any non-null reference values x and y, multiple invocations of x.equals(y) consistently return true or consistently return false, provided no information used in equals comparisons on the objects is modified.<br>For any non-null reference value x, x.equals(null) should return false.<br>The equals method for class Object implements the most discriminating possible equivalence relation on objects; that is, for any non-null reference values x and y, this method returns true if and only if x and y refer to the same object (x == y has the value true).</p><p>Note that it is generally necessary to override the hashCode method whenever this method is overridden, so as to maintain the general contract for the hashCode method, which states that equal objects must have equal hash codes.</p></blockquote><h5 id="下面给出编写一个完美的-equals-方法的建议："><a href="#下面给出编写一个完美的-equals-方法的建议：" class="headerlink" title="下面给出编写一个完美的 equals 方法的建议："></a>下面给出编写一个完美的 equals 方法的建议：</h5><ol><li><p>显式参数命名为 otherObject, 稍后需要将它转换成另一个叫做 other 的变量。 </p></li><li><p>检测 this 与 otherObject 是否引用同一个对象:<br> if (this = otherObject) return true;</p><p> 这条语句只是一个优化。 实际上， 这是一种经常采用的形式。 因为计算这个等式要比一个一个地比较类中的域所付出的代价小得多。</p></li><li><p>检测 otherObject 是否为 null , 如果为 null , 返回 false。 这项检测是很必要的。<br>if (otherObject = null) return false;</p></li><li><p>比较 this 与 otherObject 是否属于同一个类。如果 equals 的语义在每个子类中有所改变， 就使用 getClass 检测:<br> if (getClass() != otherObject.getCIassO) return false;</p><p> 如果所有的子类都拥有统一的语义， 就使用 instanceof 检测:<br> if (!(otherObject instanceof ClassName)) return false;</p></li><li><p>将 otherObject 强制转换为相应的类类型变量: </p><p>ClassName other = (ClassName) otherObject</p><p>因为传入的参数是 Object 对象类型，因此这里必须要做强制类型转换。否则 otherObject 无法调用 Employee 类的方法。</p></li></ol><p>6）现在开始对所有需要比较的域进行比较了。使用 == 比较基本类型域，使用equals比较对象域。如果所有的域都匹配，就返回true; 否则返回false。</p><p>  return field1 == other.field1 &amp;&amp; Objects.equals(fie1d2, other.field2)</p><p>  如果在子类中重新定义equals, 就要在其中包含调用super.equals(other).</p><h5 id="参考案例："><a href="#参考案例：" class="headerlink" title="参考案例："></a>参考案例：</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span>  <span class="token keyword">int</span> id<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">,</span> <span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span> id <span class="token operator">=</span> id<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> otherObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> otherObject<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>otherObject <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> otherObject<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token class-name">Employee</span> other <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Employee</span><span class="token punctuation">)</span> otherObject<span class="token punctuation">;</span>        <span class="token keyword">return</span> id <span class="token operator">==</span> other<span class="token punctuation">.</span>id<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="关于equals方法的补充说明"><a href="#关于equals方法的补充说明" class="headerlink" title="关于equals方法的补充说明"></a>关于equals方法的补充说明</h5><p>有些作者认为不应该利用 getClass 检测， 因为这样不符合置换原则。</p><p>有一个应用 AbstractSet 类的 equals 方法的典型例子， 它将检测两个集合是否有相同的元素。<br>AbstractSet 类有两个具体子类: TreeSet 和 HashSet, 它们分别使用不同的算法实现查找集合元素的操作。<br>无论集合采用何种方式实现， 都需要拥有对任意两个集合进行比较的功能。</p><p>然而， 集合是相当特殊的一个例子， 应该将 AbstractSetequals 声明为 final , 这是因为没有任何一个子类需要重定义集合是否相等的语义。<br>事实上， 这个方法并没有被声明为 final, 这样做，可以让子类选择更加有效的算法对集合进行是否相等的检测。</p><p>下面可以从两个截然不同的情况看一下这个问题: </p><ul><li>如果子类能够拥有自己的相等概念， 则对称性需求将强制采用 getClass 进行检测</li><li>如果由超类决定相等的概念， 那么就可以使用 instanceof 进行检测， 这样可以在不同子类的对象之间进行相等的比较。</li></ul><p>在雇员和经理的例子中（Manager 继承自 Employee，详见 Java核心技术卷1 5.2.3）， 只要对应的域相等， 就认为两个对象相等。 </p><p>如果两个 Manager 对象所对应的姓名、 薪水和雇佣日期均相等， 而奖金不相等， 就认为它们是不相同的， 因此， 可以使用 getClass 检测。</p><p>但是，假设使用雇员的 ID 作为相等的检测标准， 并且这个相等的概念适用于所有的子类， 就可以使用 instanceof 进行检测， 并应该将 Employee.equals 声明为 final。</p><p><em>注：本文中的例子为了更好地帮助理解，做了一些简化，假定用ID作为相等的检测标准，且不适用于子类，因此还是用 getClass 做检测。</em></p><h5 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h5><p>下面代码有什么问题呢？</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Employee</span> other<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> other <span class="token operator">!=</span> <span class="token keyword">null</span>                <span class="token operator">&amp;&amp;</span> <span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> other<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token operator">&amp;&amp;</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> other<span class="token punctuation">.</span>name<span class="token punctuation">)</span>                <span class="token operator">&amp;&amp;</span> salary <span class="token operator">==</span> other<span class="token punctuation">.</span>salary                <span class="token operator">&amp;&amp;</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>hireDay<span class="token punctuation">,</span> other<span class="token punctuation">.</span>hireDay<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个方法声明的显式参数类型是 Employee。<br><strong>其结果并没有覆盖 Object 类的 equals 方 法， 而是定义了一个完全无关的方法。</strong></p><p>为了避免发生类型错误， 可以使用 @Override 对覆盖超类的方法进行标记: </p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span> <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> other<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果出现了错误， 并且正在定义一个新方法， 编译器就会给出错误报告。 例如， 假设将下面的声明添加到 Employee 类中:</p><p>@Override public boolean equals(Employee other)</p><p>就会看到一个错误报告， 这是因为这个方法并没有覆盖超类 Object 中的任何方法。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaCoreTech-02-Java基本程序设计结构01</title>
      <link href="/2021/08/06/javacoretech/javacoretech-02-java-ji-ben-cheng-xu-she-ji-jie-gou-01/"/>
      <url>/2021/08/06/javacoretech/javacoretech-02-java-ji-ben-cheng-xu-she-ji-jie-gou-01/</url>
      
        <content type="html"><![CDATA[<h2 id="Java的基本程序设计结构（1）——示例、注释、数据类型、变量"><a href="#Java的基本程序设计结构（1）——示例、注释、数据类型、变量" class="headerlink" title="Java的基本程序设计结构（1）——示例、注释、数据类型、变量"></a>Java的基本程序设计结构（1）——示例、注释、数据类型、变量</h2><blockquote><p>Java学习笔记系列-02</p><p>《Java核心技术卷I——基础知识》 第3章 Java的基本程序设计结构</p><p>略去：第2章 Java程序设计环境（主要介绍了Java的下载、安装、启动等）</p><p>《Core Java Volume I-Fundamentals(10th Edition) 》 Cay S.Horstmann</p></blockquote><h3 id="1-一个简单的Java应用程序"><a href="#1-一个简单的Java应用程序" class="headerlink" title="1 一个简单的Java应用程序"></a>1 一个简单的Java应用程序</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FirstSample</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"We will not use 'Hello, World!'"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>Java区分大小写。</li><li>关键字 public 称为访问修饰符(access modifier)，控制程序其他部分对这段代码的访问级別。</li><li>关键字 class 表明 Java 程序中的全部内容都包含在类中。<ul><li>Java 应用程序中的全部内容都必须放置在类中。</li></ul></li><li>Java中定义类名必须以字母开头，后面可以跟字母和数字的任意组合。例：FirstSample<ul><li>标准的命名规范为: 类名是以大写字母开头的名词。多个单词的第一个字母都应该大写。</li><li>骆驼命名法（CamelCase）。</li></ul></li><li>源代码的文件名必须与公共类的名字相同，并用.java作为扩展名。例：FirstSample.java<ul><li>再次提醒大家注意，大小写是非常重要的，千万不能写成firstsample.java</li></ul></li><li>建议：把匹配的大括号上下对齐。</li><li>Java 中的所有函數都属于某个类的方法(标准 术语将其称为方法， 而不是成员函数)。<ul><li>因此， Java 中的 main 方法必须有一个外壳类。</li></ul></li><li>在 Java 中， 每个句子必须用分号结束。</li><li>Java 使用的通用语法是：object.method(parameters)<ul><li>这等价于函数调用。</li></ul></li></ul><h3 id="2-注释"><a href="#2-注释" class="headerlink" title="2 注释"></a>2 注释</h3><ul><li>在 Java 中， 有 3 种标 记注释的方式。</li><li>(1)最常用的方式是使用 //, 其注释内容从 // 开始到本行结尾。</li><li>(2)当需要长篇的注释时，既可以在每行的注释前面标记/，/ 也可以使用/<em>和</em>/将一段比较长的注释括起来。</li><li>(3)最后，第3种注释可以用来自动地生成文档。这种注释以 /**开始，以 */ 结束。  <pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * This is the first sample program in Core Java Chapter 3 * Aversion 1.01 1997-03-22 * @author Gary Cornell */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FirstSample</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"We will not use 'Hello, World!'"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>警告: 在 Java 中， /* */ 注释不能嵌套。也就是说，不能简单地把代码用 /* 和 */ 括起来<br>作为注释， 因为这段代码本身可能也包含一个 */ .</li></ul></li></ul><h3 id="3-数据类型"><a href="#3-数据类型" class="headerlink" title="3 数据类型"></a>3 数据类型</h3><ul><li>Java是一种强类型语言。这就意味着必须为每一个变量声明一种类型。</li><li>在Java中，一共共有 8 种基本类型 (primitive type)<ul><li>其中有 4 种整型</li><li>2 种浮点类型</li><li>1 种用于表示 Unicode 编码的字符单元的字符类型char</li><li>1 种用于表示真值的 boolean 类型</li></ul></li><li>注意：大数值 big number 并不是一种新的Java类型，而是一个Java对象。</li></ul><h5 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h5><ul><li><p>整型用于表示没有小数部分的数值，它允许是负数。Java 提供了 4 种整型。</p><ul><li>字节数从少到多依次是：byte，short，int，long</li></ul>  <br><table><thead><tr><th>类型</th><th>存储需求</th><th>取值范围</th></tr></thead><tbody><tr><td>int</td><td>4字节</td><td>-2 147 483 648 ～ 2 147 483 647 ( 正好超过 20 亿 )</td></tr><tr><td>short</td><td>2字节</td><td>-32 768 ～ 32 767</td></tr><tr><td>long</td><td>8字节</td><td>-9223372036854775B08 ～ 9223372036854775807</td></tr><tr><td>byte</td><td>1字节</td><td>-128 ～ 127</td></tr></tbody></table>  <br></li><li><p>在通常情况下，int类型最常用。</p></li><li><p>byte 和 short 类型主要用于特定的应用场合。</p><ul><li>例如，底层的文件处理或者需要控制占用存储空间量的大数组。</li></ul></li><li><p>在 Java 中，整型的范围与运行Java代码的机器无关。</p><ul><li>移植性：这就解决了跨平台/跨操作系统移植带来的诸多问题。</li><li>与此相反， C 和 C++ 程序需要针对不同的处理器选择最为高效的整型<ul><li>这样就有可能造成一个在32位处理器上运行很好的C程序在16位系统上运行却发生整数溢出。</li></ul></li><li>Java 程序必须保证 在所有机器上都能够得到相同的运行结果。</li></ul></li><li><p>长整型数值有一个后缀 L 或 l (如4000000000L) 。</p><ul><li>建议用：大写L，因为小写 l 和 1容易混淆。</li></ul></li><li><p>十六进制数值有一个前缀 Ox 或 0X；如 OxCAFEL 。</p></li><li><p>八进制有一个前缀 0 , 例如，010 对应八进制中的 8。</p><ul><li>显然，八进制表示法比较容易混淆，所以建议最好不要使用八进制常数。</li></ul></li><li><p>从Java 7开始，加上前缀 0b 或 0B 就可以写二进制数。例如，OblOO丨就是 9。</p></li><li><p>另外，同样是从Java 7开始，还可以为数字字面量加下划线</p><ul><li>如用1_000_000(或册1丨丨丨_0100_0丨0 0_丨0 00_0000) 表示一百万。</li><li>这些下划线只是为丫让人更易读。Java 编译器会去除这些下划线。</li></ul></li><li><p><strong>注意，Java 没有任何无符号(unsigned) 形式的 int、long、short 或 byte 类型。</strong></p></li></ul><h5 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h5><ul><li><p>浮点类型用于表示有小数部分的数值。在 Java 中有两种浮点类型。</p><br><table><thead><tr><th>类型</th><th>存储需求</th><th>取值范围</th></tr></thead><tbody><tr><td>float</td><td>4字节</td><td>大约 ± 3.402 823 47E+38F (有效位数为 6 ~ 7 位)</td></tr><tr><td>double</td><td>8字节</td><td>大约 ± 1.797 693 134 862 315 70E+308 (有效位数为 15 位)</td></tr></tbody></table><br></li><li><p>double 表示这种类型的数值精度是 float 类型的两倍(有人称之为双精度数值)。</p></li><li><p><strong>绝大部分应用程序都采用 double 类型。</strong></p><ul><li>在很多情况下， float 类型的精度很难满足需求。</li><li>实际上，只有很少的情况适合使用 float 类型。例如，需要单精度数据的库，或者需要存储大量数据。</li></ul></li><li><p>float类型的数值有一个后缀F或f (例如，3.14F)</p><ul><li><strong>没有后缀F的浮点数值(如3.14) 默 认为 double 类型。</strong></li><li>当然，也可以在浮点数值后面添加后缀 D 或 d (例如，3.14D)。</li></ul></li><li><p>下面是用于表示溢出和出错情况的3个特殊的浮点数值。例如，一个正整数处以0的结果为正无穷大。计算0/0或者负数的平方根结果为NaN。</p><ul><li>正无穷大；常量Double_POSITIVE_INFINITY</li><li>负无穷大；Double.NEGATIVEJNFINITY</li><li>NaN（不是一个数字）；Double.NaN ( 以及相应的 Float 类型的常量)</li></ul></li><li><p>特别说明：</p><ul><li>不能这样检测一个特定值是否等于Double.NaN：<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">=</span> <span class="token class-name">Double<span class="token punctuation">.</span>NaN</span><span class="token punctuation">)</span> <span class="token comment">// is never true</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>所有“ 非数值” 的值都认为是不相同的。 然而， 可以使用 Double.isNaN 方法:<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Double</span><span class="token punctuation">.</span><span class="token function">isNaN</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// check whether x is "not a number"  </span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul></li><li><p>警告:浮点数值不适用于无法接受舍入误差的金融计算中。</p><ul><li>例如，命令System.out.println ( 2.0-1.1 ) 将打印出 0.8999999999999999, 而不是人们想象的 0.9。</li><li>这种舍入误差的主要 原因是浮点数值采用二进制系统表示， 而在二进制系统中无法精确地表示分数 1/10。</li><li>这就好像十进制无法精确地表示分数 1/3 —样。</li><li>如果在数值计算中不允许有任何舍入误差，就应该使用 BigDecimal 类。</li></ul></li></ul><h5 id="char-类型"><a href="#char-类型" class="headerlink" title="char 类型"></a>char 类型</h5><ul><li><strong>警告： 我们强烈建议不要在程序中使用 char 类型， 除非确实需要处理 UTF-16 代码单元。最好 将字符串作为抽象数据类型处理。</strong></li><li>在 Java 中， char 类型描述了 UTF-16 编码中的一个代码单元。</li><li>char 类型原本用于表示单个字符。<ul><li>不过， 现在情况已经有所变化。</li><li>如今， 有些 Unicode 字符可以用一个 char 值描述， 另外一些 Unicode 字符则需要两个 char 值。</li></ul></li><li>char 类型的字面量值要用单引号括起来。<ul><li>例如: W 是编码值为 65 所对应的字符常量。</li><li>它与”A”不同，”A”是包含一个字符A的字符串。</li><li>char类型的值可以表示为十六进制值，其范围从 \u0000 到 \Uffff 例如 W2122 表示注册符号 (TM), \u03C0 表示希腊字母pai。</li></ul></li></ul><h5 id="Unicode和char类型"><a href="#Unicode和char类型" class="headerlink" title="Unicode和char类型"></a>Unicode和char类型</h5><ul><li>从 Java SE 5.0 开 始。 码 点 ( code point ) 是指与一个编码表中的某个字符对应的代码值。</li><li>在 Unicode 标准中， 码点采用十六进制书写，并加上前缀U+, 例如U+0041就是拉丁字母A的码点。</li><li>Unicode的 码点可以分成 17 个代码级别(codeplane)。</li><li>第一个代码级别称为基本的多语言级别(basic multilingual plane ), 码点从 U+0000 到 U+FFFF , 其中包括经典的 Unicode 代码;</li><li>其余的 16 个级别码点从U+10000到U+10FFFF, 其中包括一些辅助字符(supplementary character)。</li><li>UTF-16 编码采用不同长度的编码表示所有 Unicode 码点。</li><li>在基本的多语言级别中， 每个字符用16位表示，通常被称为代码单元(codeunit);</li><li>而辅助字符采用一对连续的代码单元进行编码。</li><li>这样构成的编码值落人基本的多语言级别中空闲的 2048 字节内， 通常被称为替代区域(surrogate area) [U+D800 ~ U+DBFF 用于第一个代码单兀，U+DC00 ~ U+DFFF 用 于第二个代码单元]。</li><li>这样设计十分巧妙，我们可以从中迅速地知道一个代码单元是一个字 符的编码，还是一个辅助字符的第一或第二部分。</li></ul><h5 id="boolean-类型"><a href="#boolean-类型" class="headerlink" title="boolean 类型"></a>boolean 类型</h5><ul><li>boolean ( 布尔)类型有两个值: false 和 true , 用来判定逻辑条件。</li><li>整型值和布尔值之间不能进行相互转换。</li><li>C++注释：在C++中，数值甚至指针可以代替boolean值。值0相当于布尔值false, 非 0 值相当于布尔值 true , 在 Java 中则不是这样，因此， Java 程序员不会遇到下述麻烦:  <pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// oops... meant x = 0</span><span class="token comment">// 在 C++ 中这个测试可以编译运行， 其结果总是 false:。</span><span class="token comment">// 而在 Java 中， 这个测试将不 能通过编译， 其原因是整数表达式 x = 0 不能转换为布尔值。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="4-变量"><a href="#4-变量" class="headerlink" title="4 变量"></a>4 变量</h3><ul><li>在Java中， 每个变量都有一个类型(type)。</li><li>在声明变量时，变量的类型位于变量名之前。 这里列举一些声明变量的示例:  <pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">double</span> salary<span class="token punctuation">;</span><span class="token keyword">int</span> vacationDays<span class="token punctuation">;</span> <span class="token keyword">long</span> earthPopulation<span class="token punctuation">;</span> <span class="token keyword">boolean</span> done<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li>可以看到， 每个声明以分号结束。 由于声明是一条完整的 Java 语句， 所以必须以分号结束。</li><li>变量名必须是一个以字母开头并由字母或数字构成的序列。</li><li>需要注意，与大多数程序设计语言相比，Java中“字母”和“数字”的范围更大。</li><li>字母包括’A’~’Z’、’a1’ ~’z’、’_’、’$’’ 或在某种语言中表示字母的任何 Unicode 字符。</li><li>例如，希腊人可以用 pai。同样，数字包括 0 ~ 9 和在某种语言中表示数字的任何 Unicode 自字符。</li><li>但是 ‘+’这样的富豪不能出现在变量名中，空格也不行。</li><li>变量名中所有的字符都是有意义的，并且大小写敏感。</li><li>变量名的长度基本上没有限制。</li><li>提示: 如果想要知道哪些 Unicode 字符属于 Java 中的“ 字母”， 可以使用 Character 类的 isJavaldentifierStart 和 isJavaldentifierPart 方法来检查。</li><li>不能使用 Java 保留字作为变量名。</li><li>可以在一行中声明多个变量。不过，不提倡使用这种风格。逐一声明每一个变量可以提高程序的可读性。<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">;</span> <span class="token comment">// both are integers</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="变量初始化"><a href="#变量初始化" class="headerlink" title="变量初始化"></a>变量初始化</h5></li><li>声明一个变量之后，必须用赋值语句对变量进行显式初始化，千万不要使用未初始化的变量。</li><li>例如， Java 编译器认为下面的语句序列是错误的:<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> vacationDays<span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>vacationDays<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token comment">// ERROR variable not initialized</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>要想对一个已经声明过的变量进行赋值， 就需要将变量名放在等号(=) 左侧， 相应取值 的 Java 表达式放在等号的右侧。<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> vacationDays<span class="token punctuation">;</span> vacationDays <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>也可以将变量的声明和初始化放在同一行中。 例如:<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> vacationDays <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>在 Java 中可以将声明放在代码中的任何地方。</li><li>在 Java 中， 变量的声明尽可能地靠近变量第一次使用的地方， 这是一种良好的程序编写 风格。</li></ul><h5 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h5><ul><li><p>在 Java 中， 利用关键字 final 指示常量。例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Constants</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">final</span> <span class="token keyword">double</span> CM_PER_INCH <span class="token operator">=</span> <span class="token number">2.54</span><span class="token punctuation">;</span>        <span class="token keyword">double</span> paperWidth <span class="token operator">=</span> <span class="token number">8.5</span><span class="token punctuation">;</span>        <span class="token keyword">double</span> paperHeight <span class="token operator">=</span> <span class="token number">11</span><span class="token punctuation">;</span>        <span class="token comment">//System.out.println("hello");</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Paper size in centimeters:"</span>                <span class="token operator">+</span> paperWidth <span class="token operator">*</span> CM_PER_INCH <span class="token operator">+</span> <span class="token string">" by "</span> <span class="token operator">+</span> paperHeight <span class="token operator">*</span> CM_PER_INCH<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>关键字 final 表示这个变量只能被赋值一次。一旦被赋值之后， 就不能够再更改了。</p></li><li><p>习惯上, 常量名使用全大写。</p></li><li><p>在 Java 中， 经常希望某个常量可以在一个类中的多个方法中使用， 通常将这些常量称为类常量。</p></li><li><p>可以使用关键字 static final 设置一个类常量。 下面是使用类常量的示例:</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Constants2</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">double</span> CM_PER_INCH <span class="token operator">=</span> <span class="token number">2.54</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">double</span> paperWidth <span class="token operator">=</span> <span class="token number">8.5</span><span class="token punctuation">;</span>        <span class="token keyword">double</span> paperHeight <span class="token operator">=</span> <span class="token number">11</span><span class="token punctuation">;</span>         <span class="token class-name">System</span><span class="token punctuation">,</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Paper size in centimeters: "</span>            <span class="token operator">+</span> paperWidth <span class="token operator">*</span> CM_PER_INCH <span class="token operator">+</span> <span class="token string">" by "</span> <span class="token operator">+</span> paperHeight <span class="token operator">*</span> CM_PER_INCH<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>需要注意， 类常量的定义位于 main方法的外部。 因此， 在同一个类的其他方法中也可 以使用这个常量。</li><li>而且， 如果一个常量被声明为 public，那么其他类的方法也可以使用这个常量。 在这个示例中，Constants2.CM_PER-INCH 就是这样一个常童。</li><li>C++ 注释: const 是 Java 保留的关键字， 但目前并没有使用。 在 Java 中， 必须使用 final 定义常量。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaCoreTech-01-Java关键特性</title>
      <link href="/2021/08/06/javacoretech/javacoretech-01-java-guan-jian-te-xing/"/>
      <url>/2021/08/06/javacoretech/javacoretech-01-java-guan-jian-te-xing/</url>
      
        <content type="html"><![CDATA[<h2 id="Java关键特性"><a href="#Java关键特性" class="headerlink" title="Java关键特性"></a>Java关键特性</h2><blockquote><p>Java学习笔记系列-01</p><p>《Java核心技术卷I——基础知识》 第1章 Java程序设计概述</p><p>《Core Java Volume I-Fundamentals(10th Edition) 》 Cay S.Horstmann</p><p>Java “白皮书”的关键术语</p></blockquote><h3 id="1-简单性"><a href="#1-简单性" class="headerlink" title="1 简单性"></a>1 简单性</h3><ul><li>Java是C++语法的一个”纯净版本</li><li>简单的另一方面是小。基本的解释器以及类支持大约仅40KB，再加上基础的标准类库和线程支持大约增加175KB。</li></ul><h3 id="2-面向对象"><a href="#2-面向对象" class="headerlink" title="2 面向对象"></a>2 面向对象</h3><ul><li>面向对象是一种程序设计技术。它将重点放在数据（即对象）和对象的接口上。</li></ul><h3 id="3-分布式"><a href="#3-分布式" class="headerlink" title="3 分布式"></a>3 分布式</h3><ul><li>Java又一个丰富的例程库，用于处理像HTTP和FTP之类的TCP/IP协议。</li><li>Java应用程序能够通过URL打开和访问网络上的对象，其便捷程度就好像访问本地文件一样。</li></ul><h3 id="4-健壮性"><a href="#4-健壮性" class="headerlink" title="4 健壮性"></a>4 健壮性</h3><ul><li>Java的设计目标之一在于使得Java编写的程序具有多方面的可靠性。</li><li>Java投入了大量的精力进行早起的问题检测、后期动态的检测，并消除了容易出错的情况。</li><li>Java和C++最大的不同在于Java采用的指针模型可以消除重写内存和损坏数据的可能性。</li><li>Java编译器能够检测出许多在其他语言中仅在运行时才能够检测出来的问题。</li></ul><h3 id="5-安全性"><a href="#5-安全性" class="headerlink" title="5 安全性"></a>5 安全性</h3><ul><li>Java可以适用于网络/分布式环境。使用Java可以构建防病毒、防篡改的系统。</li><li>从一开始，Java就设计成能够防范各种工具，包括：<ul><li>运行时堆栈溢出。如蠕虫和病毒常用的攻击手段。</li><li>破坏自己的进程空间之外的内存。</li><li>未经授权读写文件。</li></ul></li><li>Java的安全模型很复杂</li></ul><h3 id="体系结构中立"><a href="#体系结构中立" class="headerlink" title="体系结构中立"></a>体系结构中立</h3><ul><li>编译器生成一个体系结构中立的目标文件格式。</li><li>只要有Java运行时系统，这些编译后的代码可以在学多处理器上运行。</li><li>Java编译器通过生成与特定的计算机体系结构无关的字节码指令来实现这一特性。</li></ul><h3 id="可移植性"><a href="#可移植性" class="headerlink" title="可移植性"></a>可移植性</h3><ul><li>与C和C++不同，Java规范中没有”依赖具体实现”的地方。基本数据类型的大小以及有关运算都做了明确的说明。</li><li>例如，Java中的int永远为32位的整数，而在C/C++中，int可能是16位整数、32位整数，也可能是编译器提供商指定的其他大小。</li><li>在Java中，数据类型具有固定的大小，这消除了代码移植时令人头痛的主要问题。</li><li>二进制数据以固定的格式进行存储和传输，消除了字节顺序的困扰。</li><li>字符串是用标准的Unicode格式存储的。</li><li>除了与用户界面相关的部分外，所有其他Java库都能很好地支持平台独立性。</li><li>你可以处理文件、正则表达式、XML、日期和时间、数据库、网络连接、线程等，而不用操心底层操作系统。</li></ul><h3 id="解释型"><a href="#解释型" class="headerlink" title="解释型"></a>解释型</h3><ul><li>Java解释器可以在任何移植了解释器的机器上执行Java字节码。</li><li>由于链接是一个增量式且轻量级的过程，所以，开发过程也变得更加快捷，更加具有探索性。</li></ul><h3 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h3><ul><li>字节码可以（在运行时刻）动态地翻译成对应运行这个应用的特定的CPU的机器码。</li><li>性能就是”适用性更强”。</li></ul><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><ul><li>多线程可以带来更好的交互响应和实时行为。</li><li>Java在当时很超前。它是第一个支持并发程序设计的主流语言。</li></ul><h3 id="动态性"><a href="#动态性" class="headerlink" title="动态性"></a>动态性</h3><ul><li>从各种角度看，Java与C或C++相比更加具有动态性。它能够适应不断发展的环境。</li><li>库中可以自由地添加新方法和实例变量，而对客户端却没有任何影响。</li><li>在Java中找出运行时类型信息十分简单。</li></ul><h3 id="关于Java的常见误解"><a href="#关于Java的常见误解" class="headerlink" title="关于Java的常见误解"></a>关于Java的常见误解</h3><ul><li>1.Java是HTML的扩展。<ul><li>Java是一种程序设计语言；HTML是一种描述网页结构的方式。</li><li>两者基本没有任何共同之处。</li></ul></li><li>2.使用XML，所以不需要Java。<ul><li>Java是一种程序设计语言；XML是一种描述数据的方式。</li><li>可以使用任何一种程序设计语言处理XML数据，而Java API对XML处理提供了很好地支持。</li></ul></li><li>3.Java是一种非常容易学习的程序设计语言。<ul><li>像Java这种功能强大的语言大都不太容易学习。</li><li>首先，必须将编写玩具式程序的轻松和 开发实际项目的艰难区分开来。</li><li>Java类库包含了数千种类和接口以及数万个函数。要想Java解决实际问题，还是需要了解不少内容的。</li></ul></li><li>4.Java将成为适用于所有平台的通用性编程语言<ul><li>从理论上讲，这是完全有可能的。</li><li>但在实际中，某些领域其他语言有更出色的表现。</li><li>Objective C和后来的Swift在iOS设备上就有着无可取代的地位，</li><li>浏览器中的处理几乎完全由JavaScript掌控。</li><li>Windows程序通常都用C++或C#编写。</li><li>Java在服务器端编程和跨平台客户端应用领域则很有优势。</li></ul></li><li>5.Java只不过是另外一种程序设计语言<ul><li>Java是一种很好的程序设计语言，很多程序设计人员喜欢Java胜过C、C++或C#。</li><li>程序设计语言的成功更多地取决于其支撑系统的能力，而不是优美的语法。</li><li>人们主要关注: 是否提供了易于实现某些功能的易用、便捷和标准的库? 是否有开发工具提供商能建立强大的编程和调试环境? 语言和工具集是否能够与其他计算基础架构整合在 一起?</li><li>Java的成功源于其类库能够让人们轻松地完成原本有一定难度的事情。例如:联网 Web 应用和并发。</li><li>Java减少了指针错误，这是一个额外的好处，因此使用Java编程的效率更高。但这些并不是Java成功的全部原因。</li></ul></li><li>6.Java是专用的，应该避免使用<ul><li>根据GPL,任何人都可以得到专利许可，允许其使用和修改Java,不过仅限于桌面和服务器平台。</li></ul></li><li>7.Java是解释型的，因此对于关键的应用程序速度太慢了<ul><li>早期的Java是解释型的。</li><li>现在Java虚拟机使用了即时编译器，因此采用Java编写的“ 热点”代码其运行速度与C++相差无几，有些情况下甚至更快。</li></ul></li><li>8.所有的Java程序都是在网页中运行的。<ul><li>所有的Java applet都是在网页浏览器中运行的。这也恰恰是applet的定义，即一种在浏览器中运行的Java程序。</li><li>然而，大多数Java程序是运行在Web浏览器之外的独立应用程序。实际上，很多Java程序都在Web服务器上运行并生成用于网页的代码。</li></ul></li><li>9.Java程序是主要的安全风险<ul><li>尽管距离Java诞生已经20年之久，与其他常用的执行平台相比，Java还是安全得多。</li></ul></li><li>10.JavaScript是Java的简易版<ul><li>JavaScript是一种在网页中使用的脚本语言，它是由Netscape发明的，原来的名字叫做LiveScript。</li><li>JavaScript的语法类似 Java,除此之外两者无任何关系当然名字有些相像。</li></ul></li><li>11.使用Java可以用廉价的Internet设备取代桌面计算机<ul><li>一些公司已经生产出Java网络计算机的原型。</li><li>不过用户还不打算放弃功能强大而便利的桌面计算机，而去使用没有本地存储而且功能有限的网络设备。 </li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《影响力密码》学习笔记</title>
      <link href="/2021/08/01/ying-xiang-li-mi-ma-xue-xi-bi-ji/"/>
      <url>/2021/08/01/ying-xiang-li-mi-ma-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="影响力密码"><a href="#影响力密码" class="headerlink" title="影响力密码"></a>影响力密码</h1><p><img src="/postimages/introduction-to-code-of-influence.png" alt="影响力密码核心要点"></p><p>完整笔记请参考文末。</p><h2 id="核心要点概述"><a href="#核心要点概述" class="headerlink" title="核心要点概述"></a>核心要点概述</h2><p><strong>影响力的定义：在不运用权力（或没有权力）的情况下，以间接的方式产生效果的能力。</strong></p><h3 id="1-明确目标"><a href="#1-明确目标" class="headerlink" title="1.明确目标"></a>1.明确目标</h3><ul><li>PASS模型</li></ul><h3 id="2-识别关键"><a href="#2-识别关键" class="headerlink" title="2.识别关键"></a>2.识别关键</h3><ul><li>SPA、情景模拟</li></ul><h3 id="3-分析阻力"><a href="#3-分析阻力" class="headerlink" title="3.分析阻力"></a>3.分析阻力</h3><ul><li>基本归因错误</li><li>8大维度阻力分析（能力、意愿 + 自身、人际、组织、物理）</li></ul><h3 id="4-施加影响"><a href="#4-施加影响" class="headerlink" title="4.施加影响"></a>4.施加影响</h3><ul><li>8大维度施加影响</li></ul><h2 id="一、明确目标"><a href="#一、明确目标" class="headerlink" title="一、明确目标"></a>一、明确目标</h2><h3 id="影响人、实现事：PASS模型"><a href="#影响人、实现事：PASS模型" class="headerlink" title="影响人、实现事：PASS模型"></a>影响人、实现事：PASS模型</h3><ul><li><p>People 影响对象</p><ul><li><p>3D地图</p><ul><li>Decision 决策层</li><li>Deploy 协调层</li><li>Do 执行层</li></ul></li></ul></li><li><p>Value 价值意义</p><ul><li><p>价值轮</p><ul><li>互赖关系</li><li>情感账户</li><li>个人认同</li><li>能力/便利</li><li>物质激励</li><li>上级赏识</li><li>平级价值</li><li>管理下级</li></ul></li></ul></li><li><p>Specific 具体量化</p><ul><li><p>量化指标</p><ul><li>显性化</li></ul></li><li><p>起名字 3+3</p><ul><li>突显核心价值、易传播、易记忆</li><li>谐音梗、打比方、用数字</li></ul></li><li><p>仪式感 5W</p><ul><li>Way、Who、When、Where、What</li></ul></li></ul></li><li><p>Schedule 时间规划</p><ul><li><p>远期时间</p><ul><li>减少抵触感</li></ul></li><li><p>近期时间</p><ul><li>增加紧迫感</li></ul></li></ul></li></ul><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><ul><li><p>其实，你是一个导演！</p><ul><li>要注重事前布局，梳理好演员表和出场顺序</li></ul></li></ul><h2 id="二、识别关键"><a href="#二、识别关键" class="headerlink" title="二、识别关键"></a>二、识别关键</h2><h3 id="三大关键点：SPA"><a href="#三大关键点：SPA" class="headerlink" title="三大关键点：SPA"></a>三大关键点：SPA</h3><ul><li><p>Key Step 关键环节</p><ul><li><p>APEC流程模型</p><ul><li><p>Activate 启动</p><ul><li>论证拍板</li><li>明事定人</li><li>启动项目</li></ul></li><li><p>Plan 计划</p><ul><li>收集建议</li><li>制定方案</li><li>试点验证</li><li>优化方案</li></ul></li><li><p>Excute 执行</p><ul><li>赋能激励</li><li>落地实施</li><li>跟踪进展</li></ul></li><li><p>Close 收尾</p><ul><li>达成结果</li><li>奖罚复盘</li></ul></li></ul></li><li><p>关键环节识别矩阵</p><ul><li>在影响人方面是否关键</li><li>在推动事方面是否关键</li></ul></li></ul></li><li><p>Key Person 关键人</p><ul><li><p>3D地图</p><ul><li><p>Decision 决策层</p><ul><li>拍板决策</li></ul></li><li><p>Deploy 协调层</p><ul><li>横向协调</li></ul></li><li><p>Do 执行层</p><ul><li>具体执行</li></ul></li></ul></li><li><p>PAIR模型</p><ul><li>Power 职权资源</li><li>Ability 能力资源</li><li>Information 信息资源</li><li>Relationship 人际资源</li></ul></li></ul></li><li><p>Key Action 关键行动</p><ul><li><p>3D地图</p></li><li><p>3层关键行动列表</p><ul><li><p>执行层</p><ul><li>执行落地</li><li>正向宣传</li><li>反馈信息</li></ul></li><li><p>协调层</p><ul><li>协调资源</li><li>分享信息</li><li>广泛搭桥</li></ul></li><li><p>决策层</p><ul><li><p>最小化决策层工作量、最大化决策层影响力</p></li><li><p>九项关键行动</p><ul><li>拍板</li><li>挂帅</li><li>表态</li><li>指派</li><li>资源</li><li>授权</li><li>过问</li><li>分享</li><li>发奖</li></ul></li></ul></li></ul></li><li><p>情景模拟法</p><ul><li><p>第一步：画流程图，画出各个节点环节图</p></li><li><p>第二步：各自找关键点、每个人分别贴出你认为的SPA关键点</p><ul><li>不要集体讨论、要独立找</li></ul></li><li><p>第三步：汇总关键点：分享你的SPA关键点分析图，其他成员补充建议完善</p></li></ul></li></ul></li></ul><h2 id="三、分析阻力"><a href="#三、分析阻力" class="headerlink" title="三、分析阻力"></a>三、分析阻力</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul><li><p>原理1：基本归因错误</p><ul><li>大多数时候，人们习惯从动机和个性这两个角度来看待和评论他人，而不是从更全面的角度来考虑。</li></ul></li><li><p>原理2：人们的行为主要受自身及他们所处环境的影响</p></li></ul><h3 id="八大维度阻力分析"><a href="#八大维度阻力分析" class="headerlink" title="八大维度阻力分析"></a>八大维度阻力分析</h3><ul><li><p>自身意愿方面的阻力</p><ul><li>认为没有意义和价值，或者觉得是在添麻烦</li></ul></li><li><p>自身能力方面的阻力</p><ul><li>不具备相关能力</li></ul></li><li><p>人际因素对被影响者意愿造成的阻力</p><ul><li>周围人不鼓励被影响者去做</li></ul></li><li><p>人际因素对被影响者能力造成的阻力</p><ul><li>周围人没有给被影响者提供帮助</li></ul></li><li><p>组织因素对被影响者意愿造成的阻力</p><ul><li>公司的激励考核也使得被影响者不愿意去推动事情</li></ul></li><li><p>组织因素对被影响者能力造成的阻力</p><ul><li>公司的工具不好用、流程或缺失或复杂</li></ul></li><li><p>物理因素对被影响者意愿造成的阻力</p><ul><li>物理空间环境对被影响者造成危险或者让其厌恶</li></ul></li><li><p>物理因素对被影响者能力造成的阻力</p><ul><li>物理空间环境影响能力发挥</li></ul></li></ul><h3 id="阻力分析的三种用法"><a href="#阻力分析的三种用法" class="headerlink" title="阻力分析的三种用法"></a>阻力分析的三种用法</h3><ul><li>事前：评估难度、制定预案</li><li>事中：识别实际阻力</li><li>事后：总结经验</li></ul><h2 id="四、施加影响"><a href="#四、施加影响" class="headerlink" title="四、施加影响"></a>四、施加影响</h2><h3 id="1-对被影响者的自身意愿施加影响"><a href="#1-对被影响者的自身意愿施加影响" class="headerlink" title="1-对被影响者的自身意愿施加影响"></a>1-对被影响者的自身意愿施加影响</h3><ul><li><p>认同意义和价值</p></li><li><p>2种模式</p><ul><li>感性方法：目睹-感受-改变</li><li>理性方法：分析-思考-改变</li></ul></li><li><p>方法1：目睹</p><ul><li>确定目睹对象：相关性</li><li>引发情感共鸣：冲击性</li><li>5种目睹对象：客户、供应商、替代产品、同行竞争者、新进入者</li><li>正面案例、反面案例</li><li>广义目睹：视频、图片、声音</li><li>引发共鸣：超出常规认知、形成强烈对比</li></ul></li><li><p>方法2：感受-亲自体验</p><ul><li>行为尝试 + 先易后难</li><li>1-行为改变认知</li><li>2-系统脱敏疗疗法</li></ul></li><li><p>方法3：理性共识会</p><ul><li><p>表达理解</p></li><li><p>认清形势</p><ul><li>重点突出后果和收益，且最好关联到被影响者个人</li></ul></li><li><p>形成共识</p></li><li><p>解决方案</p></li></ul></li></ul><h3 id="2-对被影响者的能力施加影响"><a href="#2-对被影响者的能力施加影响" class="headerlink" title="2-对被影响者的能力施加影响"></a>2-对被影响者的能力施加影响</h3><ul><li><p>方法1：减法-降低难度</p><ul><li>拆分-化难为易</li><li>聚焦-减轻负担</li><li>形象-易于理解</li></ul></li><li><p>方法2：加法-提升能力</p><ul><li><p>组织相关培训</p></li><li><p>唤醒成功经验</p><ul><li>注意找典型绩优样本</li></ul></li><li><p>管理未来预期</p></li></ul></li></ul><h3 id="3-通过人际因素对被影响者的意愿施加影响"><a href="#3-通过人际因素对被影响者的意愿施加影响" class="headerlink" title="3-通过人际因素对被影响者的意愿施加影响"></a>3-通过人际因素对被影响者的意愿施加影响</h3><ul><li><p>找到能影响被影响者的人鼓励、带动被影响者去做</p></li><li><p>方法1：管理者-以身作则</p><ul><li>言行影响方向、九项关键行动</li></ul></li><li><p>方法2：意见领袖-传递正能量</p><ul><li>公开表态、管理预期</li><li>意见领袖一定要找，一方面是效果大、另一方面是要防止变成反面意见领袖</li></ul></li><li><p>方法3：树立榜样</p><ul><li><p>确立人们在组织中的行为规范</p></li><li><p>巧妙选择</p><ul><li>选择正向榜样、和大家差不多的普通人</li></ul></li><li><p>建立规范</p></li><li><p>扩大宣传</p></li></ul></li><li><p>方法4：专项小组-上传下达</p><ul><li>直接互惠、间接互惠</li></ul></li><li><p>方法5：消极传播者-消除影响源</p><ul><li>转化 + 转移</li></ul></li></ul><h3 id="4-通过人际因素对被影响者的能力施加影响"><a href="#4-通过人际因素对被影响者的能力施加影响" class="headerlink" title="4-通过人际因素对被影响者的能力施加影响"></a>4-通过人际因素对被影响者的能力施加影响</h3><ul><li><p>借助人际的力量为被影响者提供帮助</p></li><li><p>方法1：求助渠道</p><ul><li>分级求助</li></ul></li><li><p>方法2：定期群策群力</p></li><li><p>方法3：互助组</p><ul><li>让被影响者之间互相帮助</li></ul></li><li><p>方法4：外包</p></li><li><p>方法5：外部专家协助</p></li></ul><h3 id="5-通过组织因素对被影响者的意愿施加影响"><a href="#5-通过组织因素对被影响者的意愿施加影响" class="headerlink" title="5-通过组织因素对被影响者的意愿施加影响"></a>5-通过组织因素对被影响者的意愿施加影响</h3><ul><li><p>设定恰当的激励和考核机制</p></li><li><p>方法1：加入或调整KPI</p></li><li><p>方法2：阶段性激励</p><ul><li>内部荣誉</li><li>冠名权</li><li>职位</li><li>提高优先级</li><li>外部荣誉</li><li>奖励家属</li></ul></li><li><p>方法3：取得和展示阶段性积极成果</p><ul><li>展示成果-仪式感</li><li>进行激励-及时感</li><li>展望成功-认同感</li></ul></li><li><p>方法4：引入竞赛机制</p><ul><li>决策层定期看到排名</li></ul></li><li><p>方法5：沉没成本激励法</p><ul><li>收集付出的成本</li><li>发现激励时机</li><li>展示沉没成本</li></ul></li></ul><h3 id="6-通过组织因素对被影响者的能力施加影响"><a href="#6-通过组织因素对被影响者的能力施加影响" class="headerlink" title="6-通过组织因素对被影响者的能力施加影响"></a>6-通过组织因素对被影响者的能力施加影响</h3><ul><li><p>提供好用的工具和优化的流程</p></li><li><p>广义工具</p><ul><li><p>思路方法</p></li><li><p>知识库</p></li><li><p>软件</p></li><li><p>硬件</p></li><li><p>资源（非钱的资源）</p><ul><li>外部资源：置换资源</li><li>收集资源供方</li><li>分析双方需求</li><li>构建置换模式</li></ul></li></ul></li><li><p>优化流程</p><ul><li><p>开通绿色通道</p></li><li><p>扩大专项授权</p></li><li><p>降低学习成本</p></li><li><p>对标优化流程</p><ul><li>1-选定标杆</li><li>2-内部流程梳理</li><li>3-标杆流程分析</li><li>4-对标找到关键优化点</li><li>5-学习运用</li></ul></li></ul></li></ul><h3 id="7-通过物理因素对被影响者的意愿施加影响"><a href="#7-通过物理因素对被影响者的意愿施加影响" class="headerlink" title="7-通过物理因素对被影响者的意愿施加影响"></a>7-通过物理因素对被影响者的意愿施加影响</h3><ul><li><p>环境暗示</p><ul><li>原理：破窗理论</li></ul></li><li><p>环境暗示-五觉感知-激活行为</p></li><li><p>视觉</p><ul><li>环境饰物、标志标语、大小、空间布局、光线、颜色</li></ul></li><li><p>听觉</p><ul><li><p>巧用节拍</p><ul><li>四二拍：简单欢快； 四三拍：平稳、明快</li></ul></li><li><p>巧用音高</p><ul><li>中间区：简约自信；次高音：热情洋溢</li></ul></li></ul></li><li><p>触觉</p><ul><li><p>增加触觉</p><ul><li>硬、粗糙的表面稳定、重视</li><li>重要资料打印出来、纸张厚</li></ul></li><li><p>巧用形状</p><ul><li>方形：激发人们认同规则</li><li>圆形：激发人们创新想法</li><li>开会可按需选择</li></ul></li></ul></li><li><p>嗅觉</p><ul><li>使用花香：薰衣草香能增加信任感</li></ul></li><li><p>味觉</p><ul><li>使用甜味：巧克力、喜茶、蛋糕</li></ul></li></ul><h3 id="8-通过物理因素对被影响者的能力施加影响"><a href="#8-通过物理因素对被影响者的能力施加影响" class="headerlink" title="8-通过物理因素对被影响者的能力施加影响"></a>8-通过物理因素对被影响者的能力施加影响</h3><ul><li><p>环境辅助，原理：</p><ul><li>为人们提供行动线索</li><li>为什么消除行动障碍</li></ul></li><li><p>方法1：视觉指引</p></li><li><p>方法2：声音指引</p></li><li><p>方法3：空间优化</p><ul><li><p>清除障碍</p></li><li><p>空间临近</p><ul><li>增加接触机会、沟通互动</li></ul></li></ul></li><li><p>工具靠近人</p></li></ul><h2 id="学习感悟"><a href="#学习感悟" class="headerlink" title="学习感悟"></a>学习感悟</h2><h5 id="我们要以一个真诚、正直的心态来使用这些方法！"><a href="#我们要以一个真诚、正直的心态来使用这些方法！" class="headerlink" title="我们要以一个真诚、正直的心态来使用这些方法！"></a>我们要以一个真诚、正直的心态来使用这些方法！</h5><h5 id="在推动项目的过程里，要充分地调动和发挥决策层的影响力，决策层可以进行九项关键行动"><a href="#在推动项目的过程里，要充分地调动和发挥决策层的影响力，决策层可以进行九项关键行动" class="headerlink" title="在推动项目的过程里，要充分地调动和发挥决策层的影响力，决策层可以进行九项关键行动"></a>在推动项目的过程里，要充分地调动和发挥决策层的影响力，决策层可以进行九项关键行动</h5><ul><li>要点：以最小成本、发挥最大影响力</li><li>关键节点要请决策层领导出来讲两句</li></ul><h5 id="推动事情进展除了行政手段以外，还可以有多种多样的方式通过提升影响力来推动。"><a href="#推动事情进展除了行政手段以外，还可以有多种多样的方式通过提升影响力来推动。" class="headerlink" title="推动事情进展除了行政手段以外，还可以有多种多样的方式通过提升影响力来推动。"></a>推动事情进展除了行政手段以外，还可以有多种多样的方式通过提升影响力来推动。</h5><h5 id="说服别人可以从价值轮进行分析、加上施加影响的8大维度，从而从空洞无物变为合情合理、有理有据。"><a href="#说服别人可以从价值轮进行分析、加上施加影响的8大维度，从而从空洞无物变为合情合理、有理有据。" class="headerlink" title="说服别人可以从价值轮进行分析、加上施加影响的8大维度，从而从空洞无物变为合情合理、有理有据。"></a>说服别人可以从价值轮进行分析、加上施加影响的8大维度，从而从空洞无物变为合情合理、有理有据。</h5><h5 id="参考书籍：王明伟《影响力密码：打开协作中的锁》"><a href="#参考书籍：王明伟《影响力密码：打开协作中的锁》" class="headerlink" title="参考书籍：王明伟《影响力密码：打开协作中的锁》"></a>参考书籍：王明伟《影响力密码：打开协作中的锁》</h5><p><img src="/postimages/code-of-influence.png" alt="影响力密码完整笔记"></p>]]></content>
      
      
      <categories>
          
          <category> 团队协作与管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Work </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Godoc In China</title>
      <link href="/2021/08/01/godoc-in-china/"/>
      <url>/2021/08/01/godoc-in-china/</url>
      
        <content type="html"><![CDATA[<h2 id="如何在国内查看Golang文档"><a href="#如何在国内查看Golang文档" class="headerlink" title="如何在国内查看Golang文档"></a>如何在国内查看Golang文档</h2><p>如何在国内查看Golang文档，一直是困扰已久的问题，通过摸索汇总了以下几种方法：</p><h3 id="【推荐】方法一：在本地启动godoc服务"><a href="#【推荐】方法一：在本地启动godoc服务" class="headerlink" title="【推荐】方法一：在本地启动godoc服务"></a>【推荐】方法一：在本地启动godoc服务</h3><p>本地执行以下命令，然后就可以在浏览器访问： <a href="http://localhost:8888/">http://localhost:8888</a>.</p><pre class="line-numbers language-golang" data-language="golang"><code class="language-golang">godoc -http=:8888<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="方法二：还是用godoc，但是本地直接利用-godoc-命令"><a href="#方法二：还是用godoc，但是本地直接利用-godoc-命令" class="headerlink" title="方法二：还是用godoc，但是本地直接利用 godoc 命令"></a>方法二：还是用godoc，但是本地直接利用 godoc 命令</h3><ul><li>本地可以通过 godoc 命令直接来查看相关文档。<pre class="line-numbers language-none"><code class="language-none"># 查看 godoc 用法$ godoc# 查看某个package用法$ godoc pkg_name # eg: godoc math# 以上会直接输出到终端，如果想要写入到文件里更方便查看，也很简单$ godoc math &gt; file_godoc_math# 查看某个package的某个函数的用法$ godoc math Absfunc Abs(x float64) float64    Abs returns the absolute value of x.    Special cases are:Abs(±Inf) = +InfAbs(NaN) = NaN<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="方法三：下载godoc到本地"><a href="#方法三：下载godoc到本地" class="headerlink" title="方法三：下载godoc到本地"></a>方法三：下载godoc到本地</h3><p><a href="https://github.com/astaxie/godoc">https://github.com/astaxie/godoc</a></p><h3 id="方法四：“科学上网”，然后访问：https-golang-org-doc"><a href="#方法四：“科学上网”，然后访问：https-golang-org-doc" class="headerlink" title="方法四：“科学上网”，然后访问：https://golang.org/doc/"></a>方法四：“科学上网”，然后访问：<a href="https://golang.org/doc/">https://golang.org/doc/</a></h3><h3 id="文章推荐：Go语言究竟好在哪里？"><a href="#文章推荐：Go语言究竟好在哪里？" class="headerlink" title="文章推荐：Go语言究竟好在哪里？"></a>文章推荐：Go语言究竟好在哪里？</h3><p><a href="https://www.infoq.cn/article/jqrMtm15lmCP_lNCJPk3">https://www.infoq.cn/article/jqrMtm15lmCP_lNCJPk3</a></p>]]></content>
      
      
      <categories>
          
          <category> Golang编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>参考资料</title>
      <link href="/2021/08/01/can-kao-zi-liao/"/>
      <url>/2021/08/01/can-kao-zi-liao/</url>
      
        <content type="html"><![CDATA[<h1 id="liukgg-github-io"><a href="#liukgg-github-io" class="headerlink" title="liukgg.github.io"></a>liukgg.github.io</h1><p>LK’s Blog, welcome to <a href="https://liukgg.github.io/">https://liukgg.github.io</a>!</p><h3 id="2019"><a href="#2019" class="headerlink" title="2019"></a>2019</h3><ul><li><a href="https://github.com/liukgg/liukgg.github.io/blob/master/golang/godoc-in-China.md">2019-2-2 国内如何看Golang的文档</a></li><li><a href="https://guides.github.com/features/mastering-markdown/">2019-1-26 Markdown语法</a></li></ul><h3 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h3><h5 id="技术类"><a href="#技术类" class="headerlink" title="技术类"></a>技术类</h5><ul><li>Java</li><li>Ruby</li><li>Golang</li><li>K8s &amp; Docker</li><li>Shell</li><li>其他：Tracing(Jaeger/Zipkin), Prometheus, Grafana, Istio, etc.</li><li>数据库<ul><li>MySQL</li><li>MongoDB</li><li>Redis</li></ul></li></ul><h5 id="杂谈"><a href="#杂谈" class="headerlink" title="杂谈"></a>杂谈</h5><ul><li>人生感悟</li><li>学习成长</li><li>技术管理</li><li>招聘面试</li></ul>]]></content>
      
      
      <categories>
          
          <category> 参考资料 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Reference </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/08/01/hexo/hello-world/"/>
      <url>/2021/08/01/hexo/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 参考资料 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Reference </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
